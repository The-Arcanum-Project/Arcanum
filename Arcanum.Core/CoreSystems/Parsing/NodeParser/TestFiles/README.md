# Ceasar Parser - Abstract Syntax Tree (AST) Reference

This document serves as a reference for the Abstract Syntax Tree (AST) generated by the Ceasar Parser. The AST is a
structured, in-memory representation of a parsed configuration file, making it easy to analyze, interpret, or transform
the data.

All nodes in the tree inherit from the base class `AstNode`.

## Statement Nodes

Statement nodes are the primary building blocks of the configuration structure. They can appear at the root of the file
or as children within a `BlockNode`.

### `RootNode`

The top-level container for the entire parsed file. It is the entry point to the AST.

* **`Statements`**: A `List<StatementNode>` containing all top-level statements found in the file.

---

### `BlockNode`

Represents a named or anonymous collection of other statements, delimited by `{}`. This is one of the most common nodes.

* **`Identifier`**: The `Token` that identifies the block.
    * For named blocks, this is the token for the name (e.g., `graphics`, `audio`, `1444.11.11`).
    * For anonymous/array blocks, this is the `LeftBrace` token (`{`).
* **`Children`**: A `List<StatementNode>` containing all the statements defined inside this block.

#### Examples

```c#
# A named block with an assignment operator
graphics = {
    vsync = yes
}

# A named block without an assignment operator
audio {
    volume = 80
}

# An anonymous block, often used for array-like structures
{
    item = value1
}

# A block identified by a date literal
1444.11.11 = {
    event = start_of_game
}
```

---

### `ContentNode`

Represents a fundamental key-value pair.

* **`Key`**: The `Token` for the key on the left-hand side. This can be an Identifier, Number, Date, or AtIdentifier.
* **`Separator`**: The `Token` for the separator used (e.g., `=`, `<=`, `>=`, `?=`).
* **`Value`**: The `ValueNode` on the right-hand side of the separator.

#### Examples

```c#
width = 1280
fullscreen ?= no
min_width <= 640
@scale = @[ 2 * 3 + 1 ]
10 = value
```

---

### `ScriptedStatementNode`

Represents a special statement type that begins with a keyword (`scripted_trigger` or `scripted_effect`), followed by a
name and a block.

* **`Keyword`**: The `Token` for the initial keyword (e.g., `scripted_trigger`).
* **`Name`**: The `Token` for the identifier of this scripted block.
* **`Children`**: A `List<StatementNode>` containing all the statements defined inside the block.

#### Examples

```c#
scripted_trigger my_custom_trigger = {
    has_trait = cool
}

scripted_effect my_custom_effect = {
    add_gold = 100
}
```

---

## Value Nodes

Value nodes represent the data on the right-hand side of a `ContentNode` or the arguments within a `FunctionCallNode`.
They all inherit from `ValueNode`.

### `LiteralValueNode`

Represents a simple, single-token value.

* **`Value`**: The `Token` for the literal.

#### Examples

The following source code snippets would be parsed into a `LiteralValueNode`:

```c#
# From: width = 1280
1280

# From: title = "MainConfig"
"MainConfig"

# From: quality = high
high

# From: vsync = yes
yes

# From: start_date = 1444.11.11
1444.11.11
```

---

### `MathExpressionNode`

Represents an inline mathematical expression. The parser does not evaluate the expression; it simply captures the tokens
within it.

* **`Tokens`**: A read-only list of all `Token`s found between `@[` and `]`.

#### Example

```c#
# From: scale = @[ 2 * 3 + 1 ]
@[ 2 * 3 + 1 ]
```

---

### `FunctionCallNode`

Represents a value that looks like a function call, such as `rgb` or `hsv`, followed by a block of arguments.

* **`FunctionName`**: The `Token` for the function's name (e.g., `rgb`).
* **`Arguments`**: A `List<ValueNode>` containing the arguments passed inside the `{}`. The arguments are themselves
  `ValueNode`s (usually `LiteralValueNode`s).

#### Examples

```c#
# From: background = rgb { 0 0 0 }
rgb { 0 0 0 }

# From: highlight = hsv { 0.8 0.6 0.9 }
hsv { 0.8 0.6 0.9 }
```

---

### `BlockValueNode`

Represents a block that is used as a value on the right-hand side of an assignment. This is distinct from a top-level
`BlockNode`.

* **`Children`**: A `List<StatementNode>` containing the statements defined inside this value block.

#### Example

This is commonly used for logical groupings like `OR` or `AND` blocks.

```c#
# In this example, the part `{ has_trait = ... }` is a BlockValueNode
OR = {
    has_trait = prominent
    artist_skill >= 0.5
}
```