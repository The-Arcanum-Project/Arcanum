using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Nexus.SourceGen;

[Generator]
public class PropertyModifierGenerator : IIncrementalGenerator
{
   public void Initialize(IncrementalGeneratorInitializationContext context)
   {
      const string targetInterfaceName = "Nexus.Core.INexus";

      var classDeclarations = context.SyntaxProvider
                                     .CreateSyntaxProvider(predicate: Predicate,
                                                           transform: Transform)
                                     .Where(x => x is not null); // Filter out the nulls

      // Combine them with the compilation
      var compilationAndClasses
         = context.CompilationProvider.Combine(classDeclarations.Collect());

      // Generate the source
      context.RegisterSourceOutput(compilationAndClasses,
                                   (spc, source) => Execute(source.Left, source.Right!, spc));
      return;

      ClassDeclarationSyntax? Transform(GeneratorSyntaxContext genSyntaxCtx, CancellationToken cancellationToken)
      {
         var classDeclaration = (ClassDeclarationSyntax)genSyntaxCtx.Node;
         var semanticModel = genSyntaxCtx.SemanticModel;

         // Get the symbol for the interface we're looking for
         var interfaceSymbol = semanticModel.Compilation.GetTypeByMetadataName(targetInterfaceName);
         if (interfaceSymbol is null)
            // The interface isn't defined in this compilation, so no classes can implement it.
            return null;

         // Get the symbol for the class we're inspecting. 
         // GetDeclaredSymbol returns ISymbol, so we must safely cast it to INamedTypeSymbol.

         // Check if the class implements the interface, using the SymbolEqualityComparer for a robust check
         if (genSyntaxCtx.SemanticModel.GetDeclaredSymbol(classDeclaration,
                                                          cancellationToken) is { } classSymbol &&
             classSymbol.AllInterfaces.Contains(interfaceSymbol,
                                                SymbolEqualityComparer.Default))
            return classDeclaration;

         return null;
      }
   }

   private bool Predicate(SyntaxNode node, CancellationToken _)
   {
      if (node is ClassDeclarationSyntax cds &&
          cds.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
         return true;

      return false;
   }

   private void Execute(Compilation compilation,
                        ImmutableArray<ClassDeclarationSyntax> classes,
                        SourceProductionContext context)
   {
      if (classes.IsDefaultOrEmpty)
         return;

      var distinctClasses = classes.Distinct();

      foreach (var classSyntax in distinctClasses)
      {
         context.CancellationToken.ThrowIfCancellationRequested();

         var semanticModel = compilation.GetSemanticModel(classSyntax.SyntaxTree);

         if (ModelExtensions.GetDeclaredSymbol(semanticModel, classSyntax) is not INamedTypeSymbol classSymbol)
            continue;

         var attributeData = classSymbol.GetAttributes()
                                        .FirstOrDefault(ad =>
                                                           ad.AttributeClass?.ToDisplayString() ==
                                                           Helpers.EXPLICIT_PROPERTIES_ATTRIBUTE_STRING);

         // Find all eligible properties and fields
         var members = Helpers.FindModifiableMembers(classSymbol, attributeData is null, context);

         // Generate the code for this class
         var sourceCode = GeneratePartialClass(classSymbol, members);

         // Add the generated source file to the compilation
         var hintName = $"{classSymbol.ContainingNamespace}.{classSymbol.Name}.PropertyModifier.g.cs";
         context.AddSource(hintName, SourceText.From(sourceCode, Encoding.UTF8));
      }
   }

   private string GeneratePartialClass(INamedTypeSymbol classSymbol, List<ISymbol> members)
   {
      var readonlyStatuses = new List<bool>();

      var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
      var className = classSymbol.Name;

      var builder = new StringBuilder();
      builder.AppendLine("// <auto-generated/>");
      builder.AppendLine("#nullable enable");
      builder.AppendLine("using Nexus.Core;");
      builder.AppendLine("using System.Runtime.CompilerServices;");
      builder.AppendLine("using System.ComponentModel;");
#if DEBUG
      builder.AppendLine("using System.Diagnostics;");
#endif
      builder.AppendLine($"namespace {namespaceName};");
      builder.AppendLine();
      builder.AppendLine($"public partial class {className}");
      builder.AppendLine("{");

      // 1. Generate the Enum
      builder.AppendLine("    public enum Field");
      builder.AppendLine("    {");
      foreach (var member in members)
      {
         var memberType = member switch
         {
            IPropertySymbol p => p.Type,
            IFieldSymbol f => f.Type,
            _ => throw new ArgumentOutOfRangeException(),
         };

         // Gather the readonly status
         var hasReadonlyAttribute = member.GetAttributes()
                                          .Any(ad => string.Equals(ad.AttributeClass?.ToDisplayString(),
                                                                   READONLY_NEXUS_ATTRIBUTE_NAME,
                                                                   StringComparison.Ordinal));
         readonlyStatuses.Add(hasReadonlyAttribute);

         // 2. Get a fully qualified name for the type
         var memberTypeName = memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
         builder.AppendLine($"        [ExpectedType(typeof({memberTypeName}))]");
         builder.AppendLine($"        {member.Name},");
      }

      builder.AppendLine("    }");
      builder.AppendLine();

      // ------- Readonly Array -------
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// A pre-generated array indicating whether a property is read-only.");
      builder.AppendLine("    /// Accessed via the 'Field' enum index.");
      builder.AppendLine("    /// </summary>");

      // Convert the list of booleans to a C# array literal string
      var arrayInitializer = string.Join(", ", readonlyStatuses.Select(s => s.ToString().ToLower()));
      builder.AppendLine($"    private static readonly bool[] _isReadOnly = {{ {arrayInitializer} }};");
      builder.AppendLine();

      // --- Generate a public accessor method for the readonly status ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Checks if a property is marked as read-only.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public bool IsPropertyReadOnly(Enum property)");
      builder.AppendLine("    {");
      // Verify that the enum value is valid
      builder.AppendLine("        Debug.Assert(Enum.IsDefined(typeof(Field), property), \"Invalid property enum value\");");
      builder.AppendLine("        return _isReadOnly[(int)((Field)property)];");
      builder.AppendLine("    }");
      builder.AppendLine();

      // 2. Generate the SetValue method
      builder.AppendLine("    public void _setValue(Enum property, object value)");
      builder.AppendLine("    {");
      // Check if the property is readonly
      builder.AppendLine("        Debug.Assert(!IsPropertyReadOnly(property), \"Attempting to set a readonly property\");");
      
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in members)
      {
         var memberType = member is IPropertySymbol p ? p.Type : ((IFieldSymbol)member).Type;
         var typeName = memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
         builder.AppendLine($"            case Field.{member.Name}:");
#if DEBUG
         builder.AppendLine($"                Debug.Assert(value is {typeName}, \"{member.Name} needs to be a {typeName}\");");
#endif
         builder.AppendLine($"                this.{member.Name} = ({typeName})value;");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      // 3. Generate the GetValue method
      //builder.AppendLine("    [PropertyGetter]");
      builder.AppendLine("    public object _getValue(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in members)
      {
         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                return this.{member.Name};");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new ArgumentOutOfRangeException(nameof(property));");
      builder.AppendLine("        }");
      builder.AppendLine("    }");

      // 4. Generate the indexer
      builder.AppendLine();
      builder.AppendLine("    public object this[Enum key]");
      builder.AppendLine("    {");
      builder.AppendLine("        get => _getValue(key);");
      builder.AppendLine("        set => _setValue(key, value);");
      builder.AppendLine("    }");

      // 5. Generate the INotifyPropertyChanged implementation
      builder.AppendLine("    public event PropertyChangedEventHandler? PropertyChanged;");
      builder.AppendLine();
      builder.AppendLine("    protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)");
      builder.AppendLine("    {");
      builder.AppendLine("        PropertyChanged?.Invoke(this, new(propertyName));");
      builder.AppendLine("    }");
      builder.AppendLine();
      builder.AppendLine("    protected bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)");
      builder.AppendLine("    {");
      builder.AppendLine("        if (EqualityComparer<T>.Default.Equals(field, value))");
      builder.AppendLine("            return false;");
      builder.AppendLine();
      builder.AppendLine("        field = value;");
      builder.AppendLine("        OnPropertyChanged(propertyName);");
      builder.AppendLine("        return true;");
      builder.AppendLine("    }");
      builder.AppendLine();

      builder.AppendLine("}"); // Close class

      return builder.ToString();
   }

   private const string READONLY_NEXUS_ATTRIBUTE_NAME = "Arcanum.Core.CoreSystems.NUI.Attributes.ReadonlyNexusAttribute";
}