using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ParserGenerator;

[Generator]
public class MapModeGenerator : IIncrementalGenerator
{
   private const string I_MAP_MODE_INTERFACE_NAME = "Arcanum.Core.CoreSystems.Map.MapModes.IMapMode";

   public void Initialize(IncrementalGeneratorInitializationContext context)
   {
      var classProvider = Helpers.CreateClassSyntaxProvider(context);

      context.RegisterSourceOutput(context.CompilationProvider.Combine(classProvider),
                                   (spc, source) => { Generate(source.Left, source.Right, spc); });
   }

   private static void Generate(Compilation compilation,
                                ImmutableArray<ClassDeclarationSyntax> classes,
                                SourceProductionContext context)
   {
      if (classes.IsDefaultOrEmpty)
         return;

      var mapModeClasses = Helpers.FindTypesImplementingInterface(compilation, classes, I_MAP_MODE_INTERFACE_NAME);

      var mapModesToGenerate = new List<MapModeInfo>();

      // Find all classes that implement IMapMode and extract their info
      foreach (var classSymbol in mapModeClasses)
      {
         // --- 1. Get the 'Name' property and its string literal ---
         var nameProperty = classSymbol.GetMembers("Name").OfType<IPropertySymbol>().FirstOrDefault();
         var namePropertySyntax =
            nameProperty?.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax() as PropertyDeclarationSyntax;

         if ((namePropertySyntax?.Initializer?.Value ?? namePropertySyntax?.ExpressionBody?.Expression) is not
             LiteralExpressionSyntax nameInitializerExpression ||
             !nameInitializerExpression.IsKind(SyntaxKind.StringLiteralExpression))
            continue;

         var mapModeName = nameInitializerExpression.Token.ValueText;

         // --- 2. Get the 'Description' property and its string literal (with a default) ---
         var description = "No description available."; // Default value
         var descProperty = classSymbol.GetMembers("Description").OfType<IPropertySymbol>().FirstOrDefault();
         var descPropertySyntax =
            descProperty?.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax() as PropertyDeclarationSyntax;

         if ((descPropertySyntax?.Initializer?.Value ?? descPropertySyntax?.ExpressionBody?.Expression) is
             LiteralExpressionSyntax descInitializerExpression &&
             descInitializerExpression.IsKind(SyntaxKind.StringLiteralExpression))
            description = descInitializerExpression.Token.ValueText;

         // --- 3. Add the extracted info to our list ---
         mapModesToGenerate.Add(new()
         {
            ClassName = classSymbol.ToDisplayString(),
            MapModeName = mapModeName,
            EnumMemberName = SanitizeForIdentifier(mapModeName),
            Description = description,
         });
      }

      if (!mapModesToGenerate.Any())
         return;

      // Generate the source code for the partial MapModeManager
      var sourceCode = GenerateManagerClass(mapModesToGenerate);
      context.AddSource("MapModeManager.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
   }

   private static string GenerateManagerClass(List<MapModeInfo> mapModes)
   {
      var builder = new StringBuilder();
      builder.AppendLine("// <auto-generated/>");
      builder.AppendLine("#nullable enable");
      builder.AppendLine();
      builder.AppendLine("using System.Collections.Generic;");
      builder.AppendLine("using Arcanum.Core.CoreSystems.Map.MapModes;");
      builder.AppendLine("using Arcanum.Core.CoreSystems.Map.MapModes.MapModeImplementations;"); // Add namespaces for the implementations
      builder.AppendLine();
      builder.AppendLine("namespace Arcanum.Core.CoreSystems.Map.MapModes");
      builder.AppendLine("{");
      builder.AppendLine("    public partial class MapModeManager");
      builder.AppendLine("    {");

      // --- Generate the Enum ---
      builder.AppendLine("        /// <summary>");
      builder.AppendLine("        /// An enum containing all available map modes.");
      builder.AppendLine("        /// </summary>");
      builder.AppendLine("        public enum MapModeType");
      builder.AppendLine("        {");
      foreach (var mode in mapModes)
      {
         builder.AppendLine($"            /// <summary>");
         builder.AppendLine($"            /// Name: {mode.MapModeName} (<see cref=\"{mode.ClassName}\"/>) <br/>");
         builder.AppendLine($"            /// Desc: {mode.Description}");
         builder.AppendLine($"            /// </summary>");
         builder.AppendLine($"            {mode.EnumMemberName},");
      }

      builder.AppendLine("        }");
      builder.AppendLine();

      // --- Generate the Dictionary and Helpers ---
      builder.AppendLine("        private static readonly Dictionary<MapModeType, IMapMode> _mapModes = new();");
      builder.AppendLine();
      builder.AppendLine("        static MapModeManager()");
      builder.AppendLine("        {");
      foreach (var mode in mapModes)
         builder.AppendLine($"            _mapModes.Add(MapModeType.{mode.EnumMemberName}, new {mode.ClassName}());");
      builder.AppendLine();
      builder.AppendLine("            InitializeMapModeManager();");

      builder.AppendLine("        }");
      builder.AppendLine();
      builder.AppendLine("        /// <summary>");
      builder.AppendLine("        /// A dictionary of all available map modes.");
      builder.AppendLine("        /// </summary>");
      builder.AppendLine("        public static IReadOnlyDictionary<MapModeType, IMapMode> AllModes => _mapModes;");
      builder.AppendLine();
      builder.AppendLine("        /// <summary>");
      builder.AppendLine("        /// Get a map mode by its enum type.");
      builder.AppendLine("        /// </summary>");
      builder.AppendLine("        /// <param name=\"type\">The enum type of the map mode.</param>");
      builder.AppendLine("        /// <returns>The corresponding IMapMode instance.</returns>");
      builder.AppendLine("        public static IMapMode Get(MapModeType type) => _mapModes[type];");

      builder.AppendLine("    }");
      builder.AppendLine("}");

      return builder.ToString();
   }

   private static string SanitizeForIdentifier(string input)
   {
      var sanitized = new string(input.Where(c => char.IsLetterOrDigit(c) || c == '_').ToArray());
      if (sanitized.Length > 0 && char.IsDigit(sanitized[0]))
         sanitized = "_" + sanitized;

      return sanitized;
   }

   private class MapModeInfo
   {
      public string ClassName { get; set; } = "";
      public string MapModeName { get; set; } = "";
      public string EnumMemberName { get; set; } = "";
      public string Description { get; set; } = "";
   }
}