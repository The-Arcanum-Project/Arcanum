using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ParserGenerator;

[Generator]
public class MapModeGenerator : IIncrementalGenerator
{
   private const string I_MAP_MODE_INTERFACE_NAME = "Arcanum.Core.CoreSystems.Map.MapModes.IMapMode";

   public void Initialize(IncrementalGeneratorInitializationContext context)
   {
      // Find all class declarations
      var classDeclarations = context.SyntaxProvider
                                     .CreateSyntaxProvider(predicate: static (s, _) => s is ClassDeclarationSyntax,
                                                           transform: static (ctx, _)
                                                              => (ClassDeclarationSyntax)ctx.Node);

      // Combine with compilation to get semantic symbols
      IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
         context.CompilationProvider.Combine(classDeclarations.Collect());

      // Register the source output action
      context.RegisterSourceOutput(compilationAndClasses,
                                   static (spc, source) => Execute(source.Item1, source.Item2, spc));
   }

   private static void Execute(Compilation compilation,
                               ImmutableArray<ClassDeclarationSyntax> classes,
                               SourceProductionContext context)
   {
      if (classes.IsDefaultOrEmpty)
         return;

      // Get the symbol for the IMapMode interface
      var mapModeInterface = compilation.GetTypeByMetadataName(I_MAP_MODE_INTERFACE_NAME);
      // The interface isn't defined, so we can't do anything.
      if (mapModeInterface == null)
         return;

      var mapModesToGenerate = new List<MapModeInfo>();

      // Find all classes that implement IMapMode and extract their info
      foreach (var classSyntax in classes)
      {
         var semanticModel = compilation.GetSemanticModel(classSyntax.SyntaxTree);
         if (ModelExtensions.GetDeclaredSymbol(semanticModel, classSyntax) is not INamedTypeSymbol classSymbol)
            continue;

         // Must implement the interface and not be abstract
         if (!classSymbol.IsAbstract &&
             classSymbol.AllInterfaces.Contains(mapModeInterface, SymbolEqualityComparer.Default))
         {
            // Find the 'Name' property
            var nameProperty = classSymbol.GetMembers("Name").OfType<IPropertySymbol>().FirstOrDefault();
            var propertySyntax =
               nameProperty?.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax() as PropertyDeclarationSyntax;

            if (propertySyntax?.Initializer?.Value is LiteralExpressionSyntax initializerValue &&
                initializerValue.IsKind(SyntaxKind.StringLiteralExpression))
               mapModesToGenerate.Add(new()
               {
                  ClassName = classSymbol.ToDisplayString(),
                  MapModeName = initializerValue.Token.ValueText,
                  EnumMemberName = SanitizeForIdentifier(initializerValue.Token.ValueText),
                  Description = classSymbol.GetMembers("Description")
                                           .OfType<IPropertySymbol>()
                                           .FirstOrDefault()
                                         ?
                                        .DeclaringSyntaxReferences
                                           .FirstOrDefault()
                                         ?
                                        .GetSyntax() is PropertyDeclarationSyntax
                                   {
                                      Initializer.Value: LiteralExpressionSyntax descInitializer,
                                   } &&
                                descInitializer.IsKind(SyntaxKind.StringLiteralExpression)
                                   ? descInitializer.Token.ValueText
                                   : "No description available.",
               });
         }
      }

      if (!mapModesToGenerate.Any())
         return;

      // Generate the source code for the partial MapModeManager
      var sourceCode = GenerateManagerClass(mapModesToGenerate);
      context.AddSource("MapModeManager.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
   }

   private static string GenerateManagerClass(List<MapModeInfo> mapModes)
   {
      var builder = new StringBuilder();
      builder.AppendLine("// <auto-generated/>");
      builder.AppendLine("#nullable enable");
      builder.AppendLine();
      builder.AppendLine("using System.Collections.Generic;");
      builder.AppendLine("using Arcanum.Core.CoreSystems.Map.MapModes;");
      builder.AppendLine("using Arcanum.Core.CoreSystems.Map.MapModes.MapModeImplementations;"); // Add namespaces for the implementations
      builder.AppendLine();
      builder.AppendLine("namespace Arcanum.Core.CoreSystems.Map.MapModes");
      builder.AppendLine("{");
      builder.AppendLine("    public partial class MapModeManager");
      builder.AppendLine("    {");

      // --- Generate the Enum ---
      builder.AppendLine("        /// <summary>");
      builder.AppendLine("        /// An enum containing all available map modes.");
      builder.AppendLine("        /// </summary>");
      builder.AppendLine("        public enum MapModeType");
      builder.AppendLine("        {");
      foreach (var mode in mapModes)
      {
         builder.AppendLine($"            /// <summary>");
         builder.AppendLine($"            /// Name: {mode.MapModeName} (<see cref=\"{mode.ClassName}\"/>) <br/>");
         builder.AppendLine($"            /// Desc: {mode.Description}");
         builder.AppendLine($"            /// </summary>");
         builder.AppendLine($"            {mode.EnumMemberName},");
      }

      builder.AppendLine("        }");
      builder.AppendLine();

      // --- Generate the Dictionary and Helpers ---
      builder.AppendLine("        private static readonly Dictionary<MapModeType, IMapMode> _mapModes = new();");
      builder.AppendLine();
      builder.AppendLine("        static MapModeManager()");
      builder.AppendLine("        {");
      foreach (var mode in mapModes)
         builder.AppendLine($"            _mapModes.Add(MapModeType.{mode.EnumMemberName}, new {mode.ClassName}());");

      builder.AppendLine("        }");
      builder.AppendLine();
      builder.AppendLine("        /// <summary>");
      builder.AppendLine("        /// A dictionary of all available map modes.");
      builder.AppendLine("        /// </summary>");
      builder.AppendLine("        public static IReadOnlyDictionary<MapModeType, IMapMode> AllModes => _mapModes;");
      builder.AppendLine();
      builder.AppendLine("        /// <summary>");
      builder.AppendLine("        /// Get a map mode by its enum type.");
      builder.AppendLine("        /// </summary>");
      builder.AppendLine("        /// <param name=\"type\">The enum type of the map mode.</param>");
      builder.AppendLine("        /// <returns>The corresponding IMapMode instance.</returns>");
      builder.AppendLine("        public static IMapMode Get(MapModeType type) => _mapModes[type];");

      builder.AppendLine("    }");
      builder.AppendLine("}");

      return builder.ToString();
   }

   private static string SanitizeForIdentifier(string input)
   {
      var sanitized = new string(input.Where(c => char.IsLetterOrDigit(c) || c == '_').ToArray());
      if (sanitized.Length > 0 && char.IsDigit(sanitized[0]))
         sanitized = "_" + sanitized;

      return sanitized;
   }

   private class MapModeInfo
   {
      public string ClassName { get; set; } = "";
      public string MapModeName { get; set; } = "";
      public string EnumMemberName { get; set; } = "";
      public string Description { get; set; } = "";
   }
}