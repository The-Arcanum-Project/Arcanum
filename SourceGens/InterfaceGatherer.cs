using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ParserGenerator;

[Generator]
public class InterfaceGatherer : IIncrementalGenerator
{
   // --- CONFIGURATION ---
   // Key: The fully qualified name of the interface to find.
   // Value: The name of the property list in the generated class.
   private static readonly Dictionary<string, string> InterfacesToRegister = new()
   {
      { "Arcanum.API.UtilServices.Search.ISearchable", "AllSearchableTypes" },
      { "Arcanum.Core.CoreSystems.NUI.IHasMapMode", "MapModeProvider" },
      { "Arcanum.Core.CoreSystems.NUI.INUI", "NUIType" },
      { "Arcanum.Core.CoreSystems.SavingSystem.AGS.IAgs", "Ags" },
   };

   public void Initialize(IncrementalGeneratorInitializationContext context)
   {
      // Find all class declarations in the compilation.
      var classProvider = context.SyntaxProvider
                                 .CreateSyntaxProvider(predicate: (node, _) => node is ClassDeclarationSyntax,
                                                       transform: (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
                                 .Collect();

      context.RegisterSourceOutput(context.CompilationProvider.Combine(classProvider),
                                   (spc, source) => { Generate(source.Left, source.Right, spc); });
   }

   private static void Generate(Compilation compilation,
                                ImmutableArray<ClassDeclarationSyntax> classes,
                                SourceProductionContext context)
   {
      if (classes.IsDefaultOrEmpty)
         return;

      var foundTypesByInterface = FoundTypesByInterface(compilation, classes);

      foreach (var entry in foundTypesByInterface)
         GenerateIndexSource(context, entry);
   }

   private static void GenerateIndexSource(SourceProductionContext context,
                                           KeyValuePair<string, List<INamedTypeSymbol>> results)
   {
      var sb = new StringBuilder();
      sb.AppendLine("// <auto-generated/>");
      sb.AppendLine("using System;");
      sb.AppendLine("using System.Collections.Generic;");
      sb.AppendLine();
      sb.AppendLine("namespace Arcanum.Core.Registry;");
      sb.AppendLine();
      sb.AppendLine($"public static class {InterfacesToRegister[results.Key]}Registry");
      sb.AppendLine("{");

      sb.AppendLine($"    public static readonly IReadOnlyList<Type> {InterfacesToRegister[results.Key]} = ");
      sb.AppendLine("    [");

      foreach (var typeSymbol in results.Value)
         sb.AppendLine($"        typeof(global::{typeSymbol.ToDisplayString()}),");

      sb.AppendLine("    ];");
      sb.AppendLine();

      sb.AppendLine("}");

      context.AddSource($"{InterfacesToRegister[results.Key]}Registry.g.cs", sb.ToString());
   }

   private static Dictionary<string, List<INamedTypeSymbol>> FoundTypesByInterface(
      Compilation compilation,
      ImmutableArray<ClassDeclarationSyntax> classes)
   {
      var foundTypesByInterface = new Dictionary<string, List<INamedTypeSymbol>>();

      foreach (var interfaceName in InterfacesToRegister.Keys)
         foundTypesByInterface[interfaceName] = [];

      foreach (var classSyntax in classes.Distinct())
      {
         var semanticModel = compilation.GetSemanticModel(classSyntax.SyntaxTree);

         if (semanticModel.GetDeclaredSymbol(classSyntax) is not INamedTypeSymbol
             {
                TypeKind: TypeKind.Class,
             } classSymbol ||
             classSymbol.IsAbstract)
            continue;

         foreach (var interfaceName in InterfacesToRegister.Keys)
         {
            var interfaceSymbol = compilation.GetTypeByMetadataName(interfaceName);
            if (interfaceSymbol != null &&
                classSymbol.AllInterfaces.Contains(interfaceSymbol, SymbolEqualityComparer.Default))
               foundTypesByInterface[interfaceName].Add(classSymbol);
         }
      }

      return foundTypesByInterface;
   }
}