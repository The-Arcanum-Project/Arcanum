using System.Text;
using Microsoft.CodeAnalysis;
using ParserGenerator.SubClasses;

namespace ParserGenerator.HelperClasses;

public static class DispatcherGeneratorHelper
{
   public static string Generate(DispatcherConfig config, List<INamedTypeSymbol> foundTypes)
   {
      var sb = new StringBuilder();
      sb.AppendLine("// <auto-generated by DispatcherGeneratorHelper/>");
      sb.AppendLine("#nullable enable");
      sb.AppendLine("using System;");
      sb.AppendLine("using System.Collections;");
      sb.AppendLine("using System.Collections.Generic;");
      sb.AppendLine("using System.Collections.Concurrent;");
      sb.AppendLine("using System.Reflection;");
      foreach (var configUsing in config.Usings)
      {
         sb.AppendLine($"using {configUsing};");
      }

      sb.AppendLine();
      sb.AppendLine($"namespace {config.Namespace};");
      sb.AppendLine();
      sb.AppendLine($"public static class {config.ClassName}");
      sb.AppendLine("{");

      // --- Generate the delegate definition ---
      sb.AppendLine($"    {config.DelegateDefinition}");
      sb.AppendLine();

      // --- Create and pre-populate the dictionary---
      sb.AppendLine($"    private static readonly ConcurrentDictionary<Type, {config.DelegateName}> _dispatchers = new()");
      sb.AppendLine("    {");
      foreach (var typeSymbol in foundTypes)
      {
         var fullTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
         var valueExpression = config.CompileTimeValueFactory(typeSymbol);
         sb.AppendLine($"        [typeof({fullTypeName})] = {valueExpression},");
      }

      sb.AppendLine("    };");
      sb.AppendLine();

      if (config is { Delegate2Definition: not null, CompileTimeValueFactoryForSecondMethod: not null })
      {
         sb.AppendLine($"    {config.Delegate2Definition}");
         sb.AppendLine();
         sb.AppendLine($"    private static readonly ConcurrentDictionary<Type, {config.DelegateName2}> _dispatchers2 = new()");
         sb.AppendLine("    {");
         foreach (var typeSymbol in foundTypes)
         {
            var fullTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var valueExpression = config.CompileTimeValueFactoryForSecondMethod(typeSymbol);
            sb.AppendLine($"        [typeof({fullTypeName})] = {valueExpression},");
         }

         sb.AppendLine("    };");
         sb.AppendLine();
      }

      // --- Generate the runtime Register method ---
      sb.AppendLine("    /// <summary>");
      sb.AppendLine("    /// Registers a type at runtime. Intended for use by plugins.");
      sb.AppendLine("    /// </summary>");
      sb.AppendLine("    public static bool Register(Type type)");
      sb.AppendLine("    {");
      sb.AppendLine($"        var methodInfo = type.GetMethod(\"{config.RuntimeMethodName}\", BindingFlags.Public | BindingFlags.Static);");
      sb.AppendLine("        if (methodInfo == null) return false;");
      sb.AppendLine();
      sb.AppendLine("        try");
      sb.AppendLine("        {");
      sb.AppendLine($"            var accessor = ({config.DelegateName})Delegate.CreateDelegate(typeof({config.DelegateName}), methodInfo);");
      sb.AppendLine("            return _dispatchers.TryAdd(type, accessor);");
      sb.AppendLine("        }");
      sb.AppendLine("        catch { return false; }");
      sb.AppendLine("    }");
      sb.AppendLine();

      // --- Generate the public API methods provided by the user --- 
      sb.AppendLine(config.PublicApiMethods);

      sb.AppendLine("}");

      return sb.ToString();
   }
}