using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ParserGenerator;

[Generator]
public class EmptyCacheGenerator : IIncrementalGenerator
{
   public const string EMPTY_GENERIC_INTERFACE = "Arcanum.Core.GameObjects.BaseTypes.IEmpty`1";

   public void Initialize(IncrementalGeneratorInitializationContext context)
   {
      // Find all class declarations in the compilation.
      var classProvider = context.SyntaxProvider
                                 .CreateSyntaxProvider(predicate: (node, _) => node is ClassDeclarationSyntax,
                                                       transform: (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
                                 .Collect();

      context.RegisterSourceOutput(context.CompilationProvider.Combine(classProvider),
                                   (spc, source) => { Generate(source.Left, source.Right, spc); });
   }

   private static void Generate(Compilation compilation,
                                ImmutableArray<ClassDeclarationSyntax> classes,
                                SourceProductionContext context)
   {
      if (classes.IsDefaultOrEmpty)
         return;

      var foundTypesByInterface = Helpers.FindTypesImplementingInterface(compilation, classes, EMPTY_GENERIC_INTERFACE);

      GenerateIndexSource(context, foundTypesByInterface);
   }

   private static void GenerateIndexSource(SourceProductionContext context,
                                           List<INamedTypeSymbol> results)
   {
      var sb = new StringBuilder();
      sb.AppendLine("// <auto-generated/>");
      sb.AppendLine("using System;");
      sb.AppendLine("using System.Collections.Generic;");
      sb.AppendLine();
      sb.AppendLine("namespace Arcanum.Core.Registry;");
      sb.AppendLine();
      sb.AppendLine($"public static class EmptyRegistry");
      sb.AppendLine("{");

      sb.AppendLine($"    public static readonly Dictionary<Type, object> Empties = new()");
      sb.AppendLine("    {");
      foreach (var typeSymbol in results)
         sb.AppendLine($"        [typeof(global::{typeSymbol.ToDisplayString()})] = global::{typeSymbol.ToDisplayString()}.Empty,");
      sb.AppendLine("    };");
      sb.AppendLine();

      // TryGetAccessor
      sb.AppendLine();
      sb.AppendLine("    public static bool TryGetEmpty<T>(out T empty) where T : class");
      sb.AppendLine("    {");
      sb.AppendLine("        if (Empties.TryGetValue(typeof(T), out var obj) && obj is T t)");
      sb.AppendLine("        {");
      sb.AppendLine("            empty = t;");
      sb.AppendLine("            return true;");
      sb.AppendLine("        }");
      sb.AppendLine();
      sb.AppendLine("        empty = null;");
      sb.AppendLine("        return false;");
      sb.AppendLine("    }");

      // Type to object TryGetAccessor
      sb.AppendLine();
      sb.AppendLine("    public static bool TryGet(Type type, out object empty)");
      sb.AppendLine("    {");
      sb.AppendLine("        if (Empties.TryGetValue(type, out empty))");
      sb.AppendLine("            return true;");
      sb.AppendLine();
      sb.AppendLine("        return false;");
      sb.AppendLine("    }");

      sb.AppendLine("}");

      context.AddSource("EmptyRegistry.g.cs", sb.ToString());
   }
}