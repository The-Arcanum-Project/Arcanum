using System.Text;
using Microsoft.CodeAnalysis;

namespace ParserGenerator.HelperClasses;

public static class EnumIndexGenerator
{
   private const string FLAGS_ATTRIBUTE = "System.FlagsAttribute";
   private const string HINT_NAME = "EnumAgsRegistry.g.cs";

   public static void RunEnumIndexGenerator(SourceProductionContext context,
                                            Dictionary<string, EnumAnalysisResult> cache)
   {
      // If the cache is empty, there's nothing to generate.
      if (!cache.Any())
         return;

      context.AddSource(HINT_NAME, GenerateRegistryClass(cache));
   }

   private static string GenerateRegistryClass(IReadOnlyDictionary<string, EnumAnalysisResult> cache)
   {
      var sb = new StringBuilder();

      sb.AppendLine("// <auto-generated/>");
      sb.AppendLine("#nullable enable");
      sb.AppendLine("using System;");
      sb.AppendLine("using System.Collections.Generic;");
      sb.AppendLine("using System.Collections.ObjectModel;");
      sb.AppendLine("using Arcanum.Core.CoreSystems.SavingSystem.AGS;");
      sb.AppendLine();

      sb.AppendLine("namespace Arcanum.Core.AgsRegistry");
      sb.AppendLine("{");

      sb.AppendLine("    /// <summary>");
      sb.AppendLine("    /// Provides a centralized, runtime registry for enum serialization metadata.");
      sb.AppendLine("    /// </summary>");
      sb.AppendLine("    public static class EnumAgsRegistry");
      sb.AppendLine("    {");
      sb.AppendLine("        private static readonly Dictionary<Type, EnumDataInfo> _registry;");
      sb.AppendLine("        public static IReadOnlyDictionary<Type, EnumDataInfo> Registry => _registry;");
      sb.AppendLine();
      sb.AppendLine("        static EnumAgsRegistry()");
      sb.AppendLine("        {");
      sb.AppendLine("            var tempRegistry = new Dictionary<Type, EnumDataInfo>();");

      foreach (var value in cache.Values)
      {
         if (!value.IsValid)
            continue;

         var enumFullName = value.EnumSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
         var isFlags = value.EnumSymbol.GetAttributeForKey(FLAGS_ATTRIBUTE) != null;

         sb.AppendLine($"            var forwardMap_{value.EnumSymbol.Name} = new Dictionary<string, string>");
         sb.AppendLine("            {");
         foreach (var field in value.FieldResults)
         {
            if (!field.IsValid || field.IsIgnored)
               continue;

            sb.AppendLine($"                {{ \"{field.FieldSymbol.Name}\", \"{field.Key}\" }},");
         }

         sb.AppendLine("            };");

         sb.AppendLine($"            var reverseMap_{value.EnumSymbol.Name} = forwardMap_{value.EnumSymbol.Name}");
         sb.AppendLine("                .ToDictionary(kvp => kvp.Value, kvp => kvp.Key, StringComparer.OrdinalIgnoreCase);");
         sb.AppendLine();

         sb.AppendLine($"            tempRegistry[typeof({enumFullName})] = new EnumDataInfo");
         sb.AppendLine("            {");
         sb.AppendLine($"                EnumType = typeof({enumFullName}),");
         sb.AppendLine($"                IsFlags = {isFlags.ToString().ToLower()},");
         sb.AppendLine($"                Mapping = forwardMap_{value.EnumSymbol.Name},");
         sb.AppendLine($"                ReverseMapping = reverseMap_{value.EnumSymbol.Name}");
         sb.AppendLine("            };");
      }

      sb.AppendLine("            _registry = tempRegistry;");
      sb.AppendLine("        }");

      sb.AppendLine();
      sb.AppendLine("        /// <summary>");
      sb.AppendLine("        /// Gets the serialized key for a specific enum member.");
      sb.AppendLine("        /// </summary>");
      sb.AppendLine("        public static string? GetKey<TEnum>(TEnum value) where TEnum : Enum");
      sb.AppendLine("        {");
      sb.AppendLine("            if (_registry.TryGetValue(typeof(TEnum), out var dataInfo))");
      sb.AppendLine("                if (dataInfo.Mapping.TryGetValue(value.ToString(), out var key))");
      sb.AppendLine("                    return key;");
      sb.AppendLine("            return null;");
      sb.AppendLine("        }");
      sb.AppendLine();
      sb.AppendLine("        /// <summary>");
      sb.AppendLine("        /// The fastest way to parse an enum from its serialized key.");
      sb.AppendLine("        /// </summary>");
      sb.AppendLine("        public static bool TryParse<TEnum>(string key, out TEnum value) where TEnum : struct, Enum");
      sb.AppendLine("        {");
      sb.AppendLine("            value = default;");
      sb.AppendLine("            if (_registry.TryGetValue(typeof(TEnum), out var dataInfo))");
      sb.AppendLine("                if (dataInfo.ReverseMapping.TryGetValue(key, out var memberName))");
      sb.AppendLine("                    return Enum.TryParse(memberName, out value);");
      sb.AppendLine("            return false;");
      sb.AppendLine("        }");

      sb.AppendLine("    }"); // End of class
      sb.AppendLine("}"); // End of namespace

      return sb.ToString();
   }
}