using System.Globalization;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ParserGenerator.HelperClasses;

public static class NexusHelpers
{
   private const string INEXUS_INTERFACE = "Nexus.Core.INexus";

   private const string NUI_CONFIG_ATTRIBUTE_NAME =
      "Arcanum.Core.CoreSystems.NUI.Attributes.NuiConfigAttribute";

   private const string NEXUS_CONFIG_ATTRIBUTE_NAME = "Nexus.Core.Attributes.NexusConfigAttribute";

   private const string DESCRIPTION_ATTRIBUTE_NAME = "System.ComponentModel.DescriptionAttribute";

   /// <summary>
   /// This transform finds any class that implements INexus.
   /// It's the gatekeeper for both generation steps.
   /// </summary>
   public static INamedTypeSymbol? GetNexusClassSymbol(GeneratorSyntaxContext context, CancellationToken token)
   {
      var classDeclaration = (ClassDeclarationSyntax)context.Node;

      if (ModelExtensions.GetDeclaredSymbol(context.SemanticModel, classDeclaration, token) is INamedTypeSymbol
          classSymbol)
      {
         var nexusInterface = context.SemanticModel.Compilation.GetTypeByMetadataName(INEXUS_INTERFACE);
         if (nexusInterface != null &&
             classSymbol.AllInterfaces.Contains(nexusInterface, SymbolEqualityComparer.Default))
            return classSymbol;
      }

      return null;
   }

   public static void RunPropertyModifierGenerator(INamedTypeSymbol classSymbol,
                                                   SourceProductionContext context,
                                                   INamedTypeSymbol enumerableSymbol,
                                                   INamedTypeSymbol ieu5ObjectSymbol,
                                                   INamedTypeSymbol iListSymbol)
   {
      var sourceCode = GeneratePropertyModifierPart(classSymbol,
                                                    Helpers.FindModifiableMembers(classSymbol, context),
                                                    enumerableSymbol,
                                                    ieu5ObjectSymbol,
                                                    iListSymbol,
                                                    context);
      var hintName = $"{classSymbol.ContainingNamespace}.{classSymbol.Name}.PropertyModifier.g.cs";
      context.AddSource(hintName, sourceCode);
   }

   private static string GeneratePropertyModifierPart(INamedTypeSymbol classSymbol,
                                                      List<ISymbol> members,
                                                      INamedTypeSymbol enumerableSymbol,
                                                      INamedTypeSymbol ieu5ObjectSymbol,
                                                      INamedTypeSymbol iListSymbol,
                                                      SourceProductionContext context)
   {
      var propConfig = new List<PropertyConfigData?>();
      var descriptions = new List<string?>();

      // List of all members that are a collection
      var collectionMembers = new List<ISymbol>();
      var listMembers = new List<ISymbol>();
      var propertyTypes = new List<ITypeSymbol>();
      var collectionItemTypes = new List<ITypeSymbol?>();

      var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
      var className = classSymbol.Name;

      var builder = new StringBuilder();
      builder.AppendLine("// <auto-generated/>");
      builder.AppendLine("#nullable enable");
      builder.AppendLine("using Nexus.Core;");
      builder.AppendLine("using Arcanum.Core.CoreSystems.CommandSystem;");
      builder.AppendLine("using System.Runtime.CompilerServices;");
      builder.AppendLine("using System.ComponentModel;");
      builder.AppendLine("using Arcanum.Core.Registry;");
      builder.AppendLine("using System.Diagnostics;");

      builder.AppendLine($"namespace {namespaceName};");
      builder.AppendLine();
      builder.AppendLine($"public partial class {className}");
      builder.AppendLine("{");

      // 1. Generate the Enum
      builder.AppendLine("    public enum Field");
      builder.AppendLine("    {");
      foreach (var member in members)
      {
         if (member is not IPropertySymbol propSym)
            continue;

         var memberType = propSym.Type;
         propertyTypes.Add(memberType);

         propConfig.Add(PropertyConfigHelper.GeneratePropertyConfigData(propSym, ieu5ObjectSymbol, context));

         // Gather the description (if any)
         var descriptionAttribute = member.GetAttributes()
                                          .FirstOrDefault(ad =>
                                                             string.Equals(ad.AttributeClass?.ToDisplayString(),
                                                                           DESCRIPTION_ATTRIBUTE_NAME,
                                                                           StringComparison.Ordinal));
         // ReSharper disable once MergeIntoPattern
         descriptions.Add(descriptionAttribute is null
                             ? null
                             : descriptionAttribute.ConstructorArguments.Length == 1 &&
                               descriptionAttribute.ConstructorArguments[0].Value is string desc
                                ? desc
                                : null);

         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         collectionItemTypes.Add(itemType);

         if (itemType != null)
         {
            collectionMembers.Add(member);
            // Check if it's a List
            if (memberType.AllInterfaces.Contains(iListSymbol, SymbolEqualityComparer.Default))
               listMembers.Add(member);
         }

         // 2. Get a fully qualified name for the type
         var memberTypeName = memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
         builder.AppendLine($"        [ExpectedType(typeof({memberTypeName}))]");
         builder.AppendLine($"        {member.Name},");
      }

      builder.AppendLine("    }");
      builder.AppendLine();

      AppendDefaultValues(builder, classSymbol, members, enumerableSymbol, ieu5ObjectSymbol, context);

      #region Property Modifiers and acessors

      builder.AppendLine("#region Property Modifier Backing Fields");
      builder.AppendLine();

      // -------- Description Array --------
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// A pre-generated array containing the description of each property, if any.");
      builder.AppendLine("    /// Accessed via the 'Field' enum index.");
      builder.AppendLine("    /// </summary>");

      var descriptionInitializer = string.Join(", ",
                                               descriptions.Select(s => s is null
                                                                           ? "null"
                                                                           : SymbolDisplay.FormatLiteral(s, true)));
      builder.AppendLine($"    private static readonly string?[] _descriptions = {{ {descriptionInitializer} }};");
      builder.AppendLine();

      // -------- Property Type Array --------
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// A pre-generated array containing the Type of each property.");
      builder.AppendLine("    /// Accessed via the 'Field' enum index.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine($"    private static readonly Type[] _propertyTypes =");
      builder.AppendLine("    {");
      foreach (var typeSymbol in propertyTypes)
      {
         var typeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
         builder.AppendLine($"        typeof({typeName}),");
      }

      builder.AppendLine("    };");
      builder.AppendLine();
      builder.AppendLine($"#endregion");
      builder.AppendLine();

      // -------- Collection Item Type Array --------
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// A pre-generated array containing the item Type for collection properties, or null otherwise.");
      builder.AppendLine("    /// Accessed via the 'Field' enum index.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine($"    private static readonly Type?[] _collectionItemTypes =");
      builder.AppendLine("    {");
      foreach (var typeSymbol in collectionItemTypes)
      {
         var typeString = typeSymbol == null
                             ? "null"
                             : $"typeof({typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})";

         builder.AppendLine($"        {typeString},");
      }

      builder.AppendLine("    };");
      builder.AppendLine();

      // ########## NUI CONFIG ##########
      builder.AppendLine();
      builder.AppendLine("#region NUI Config Accessors");

      AppendIntBitsAsBools(builder, propConfig);

      builder.AppendLine("#endregion");

      builder.AppendLine("#region Property Modifier Methods");
      builder.AppendLine();

      // --- Generate a public accessor method for the Description ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Gets the description of a property, if any.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public string? GetDescription(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        Debug.Assert(Enum.IsDefined(typeof(Field), property), \"Invalid property enum value\");");
      builder.AppendLine("        return _descriptions[(int)((Field)property)];");
      builder.AppendLine("    }");
      builder.AppendLine();

      builder.AppendLine("#endregion");
      builder.AppendLine();

      #endregion

      AppendMinMax(builder, propConfig);

      #region Get and Set Value methods

      // 2. Generate the SetValue method
      // with an on property changed call and a check if the value actually changed
      builder.AppendLine("    public void _setValue(Enum property, object value)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in members)
      {
         var memberType = member is IPropertySymbol p ? p.Type : ((IFieldSymbol)member).Type;
         var typeName = memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

         builder.AppendLine($"            case Field.{member.Name}:");
#if DEBUG
         builder.AppendLine($"                Debug.Assert(value is {typeName}, \"{member.Name} needs to be a {typeName}\");");
#endif
         if (collectionMembers.Contains(member))
         {
            var itemType = memberType.SpecialType == SpecialType.System_String
                              ? "string"
                              : (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault()?.ToDisplayString();
            builder.AppendLine($"                 if (this.{member.Name}.SequenceEqual((System.Collections.Generic.ICollection<{itemType}>)value))");
            builder.AppendLine("                 {");
            builder.AppendLine($"                     this.{member.Name} = ({typeName})value;");
            builder.AppendLine("                     OnPropertyChanged(nameof(this." + member.Name + "));");
            builder.AppendLine("                 }");
         }
         else
         {
            builder.AppendLine($"                if (!EqualityComparer<{typeName}>.Default.Equals(this.{member.Name}, ({typeName})value))");
            builder.AppendLine("                {");
            builder.AppendLine($"                    this.{member.Name} = ({typeName})value;");
            builder.AppendLine("                    OnPropertyChanged(nameof(this." + member.Name + "));");
            builder.AppendLine("                }");
         }

         builder.AppendLine("                break;");
      }

      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      builder.AppendLine("    public object _getValue(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in members)
      {
         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                return this.{member.Name};");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new ArgumentOutOfRangeException(nameof(property));");
      builder.AppendLine("        }");
      builder.AppendLine("    }");

      // --- Public accessor method for the Property Type ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Gets the Type of a property.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public Type GetNxPropType(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        Debug.Assert(Enum.IsDefined(typeof(Field), property), \"Invalid property enum value\");");
      builder.AppendLine("        return _propertyTypes[(int)((Field)property)];");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- Public accessor method for the Collection Item Type ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Gets the item Type for a collection property, or null if the property is not a collection.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public Type? GetNxItemType(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        Debug.Assert(Enum.IsDefined(typeof(Field), property), \"Invalid property enum value\");");
      builder.AppendLine("        return _collectionItemTypes[(int)((Field)property)];");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- IsCollection ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Checks if a property is a collection.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public bool IsCollection(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        Debug.Assert(Enum.IsDefined(typeof(Field), property), \"Invalid property enum value\");");
      builder.AppendLine("        return GetNxItemType(property) != null;");
      builder.AppendLine("    }");
      builder.AppendLine();

      #endregion

      #region Collection Manipulation Methods

      builder.AppendLine();
      builder.AppendLine("#region Collection Manipulation Methods");
      builder.AppendLine();

      // --- AddToCollection ---
      builder.AppendLine("    public void _addToCollection(Enum property, object item)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in collectionMembers)
      {
         var memberType = member is IPropertySymbol p ? p.Type : ((IFieldSymbol)member).Type;
         // Get the collection's item type, e.g., 'string' from 'ObservableRangeCollection<string>'
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                Debug.Assert(item is {itemTypeName}, \"Item needs to be a {itemTypeName}\");");
         builder.AppendLine($"                Debug.Assert(this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}>, \"Property '{member.Name}' is not a collection.\");");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}> {member.Name}_coll && item is {itemTypeName} {member.Name}_typedItem)");
         builder.AppendLine($"                    {member.Name}_coll.Add({member.Name}_typedItem);");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' is not a collection.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- RemoveFromCollection ---
      builder.AppendLine("    public void _removeFromCollection(Enum property, object item)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in collectionMembers)
      {
         var memberType = member is IPropertySymbol p ? p.Type : ((IFieldSymbol)member).Type;
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                Debug.Assert(item is {itemTypeName}, \"Item needs to be a {itemTypeName}\");");
         builder.AppendLine($"                Debug.Assert(this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}>, \"Property '{member.Name}' is not a collection.\");");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}> {member.Name}_coll && item is {itemTypeName} {member.Name}_typedItem)");
         builder.AppendLine($"                    {member.Name}_coll.Remove({member.Name}_typedItem);");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' is not a collection.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- ClearCollection ---
      builder.AppendLine("    public void _clearCollection(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in collectionMembers)
      {
         var memberType = (member is IPropertySymbol p) ? p.Type : ((IFieldSymbol)member).Type;
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                Debug.Assert(this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}>, \"Property '{member.Name}' is not a collection.\");");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}> {member.Name}_coll)");
         builder.AppendLine($"                    {member.Name}_coll.Clear();");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' is not a collection.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      builder.AppendLine("#endregion");
      builder.AppendLine();

      // --- InsertIntoCollection ---
      builder.AppendLine("    public void _insertIntoCollection(Enum property, int index, object item)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in listMembers)
      {
         var memberType = (member is IPropertySymbol p) ? p.Type : ((IFieldSymbol)member).Type;
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                Debug.Assert(item is {itemTypeName}, \"Item must be of type {itemTypeName}\");");
         builder.AppendLine($"                Debug.Assert(this.{member.Name} is System.Collections.Generic.IList<{itemTypeName}>, \"Property '{member.Name}' must be an IList to support InsertAt.\");");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.IList<{itemTypeName}> {member.Name}_list && item is {itemTypeName} {member.Name}_typedItem)");
         builder.AppendLine($"                    {member.Name}_list.Insert(index, {member.Name}_typedItem);");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' does not support indexed insertion.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- RemoveFromCollectionAt ---
      builder.AppendLine("    public void _removeFromCollectionAt(Enum property, int index)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in listMembers)
      {
         var memberType = (member is IPropertySymbol p) ? p.Type : ((IFieldSymbol)member).Type;
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                Debug.Assert(this.{member.Name} is System.Collections.Generic.IList<{itemTypeName}>, \"Property '{member.Name}' must be an IList to support RemoveAt.\");");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.IList<{itemTypeName}> {member.Name}_list)");
         builder.AppendLine($"                    {member.Name}_list.RemoveAt(index);");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' does not support indexed removal.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- AddRangeToCollection (for Clear undo) ---
      builder.AppendLine("    public void _addRangeToCollection(Enum property, System.Collections.IEnumerable items)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in collectionMembers)
      {
         var memberType = (member is IPropertySymbol p) ? p.Type : ((IFieldSymbol)member).Type;
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}> {member.Name}_coll)");
         builder.AppendLine("                {");
         builder.AppendLine("                    foreach (var item in items.Cast<object>().ToList())");
         builder.AppendLine($"                        {member.Name}_coll.Add(({itemTypeName})item);");
         builder.AppendLine("                }");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' is not a collection.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      #endregion

      #region Indexer

      // Indexer has to call those methods and not use faster _setValue or _getValue to ensure PropertyChanged is called
      builder.AppendLine();
      builder.AppendLine("    public object this[Enum key]");
      builder.AppendLine("    {");
      builder.AppendLine("        get {");
      builder.AppendLine("            object value = null!;");
      builder.AppendLine("            Nx.ForceGet(this, key, ref value);");
      builder.AppendLine("            return value;");
      builder.AppendLine("        }");
      builder.AppendLine("        set => Nx.ForceSet(value, this, key);");
      builder.AppendLine("    }");

      #endregion

      #region GetAllProperties

      builder.AppendLine();
      builder.AppendLine("    public List<Enum> GetAllProperties()");
      builder.AppendLine("    {");
      builder.AppendLine("        return Enum.GetValues(typeof(Field)).Cast<Enum>().ToList();");
      builder.AppendLine("    }");

      #endregion

      #region Property Changed

      builder.AppendLine();
      builder.AppendLine("#region INotifyPropertyChanged Implementation");
      builder.AppendLine();
      builder.AppendLine("    public event PropertyChangedEventHandler? PropertyChanged;");
      builder.AppendLine();
      builder.AppendLine("    protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)");
      builder.AppendLine("    {");
      builder.AppendLine("        PropertyChanged?.Invoke(this, new(propertyName));");
      builder.AppendLine("    }");
      builder.AppendLine();
      builder.AppendLine("    protected bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)");
      builder.AppendLine("    {");
      builder.AppendLine("        if (EqualityComparer<T>.Default.Equals(field, value))");
      builder.AppendLine("            return false;");
      builder.AppendLine();
      builder.AppendLine("        field = value;");
      builder.AppendLine("        OnPropertyChanged(propertyName);");
      builder.AppendLine("        return true;");
      builder.AppendLine("    }");
      builder.AppendLine();
      builder.AppendLine("#endregion");
      builder.AppendLine();

      #endregion

      // ToString and Equals/GetHashCode
      AppendNexusObjectOverrides(builder, classSymbol);

      builder.AppendLine("}"); // Close class

      return builder.ToString();
   }

   private static void AppendNexusObjectOverrides(StringBuilder builder, INamedTypeSymbol classSymbol)
   {
      // we get the NexusConfig class attribute to find the bool whether to generate these overrides
      var nexusConfigAttribute = classSymbol.GetAttributes()
                                            .FirstOrDefault(ad =>
                                                               string.Equals(ad.AttributeClass?.ToDisplayString(),
                                                                             NEXUS_CONFIG_ATTRIBUTE_NAME,
                                                                             StringComparison.Ordinal));

      if (nexusConfigAttribute == null)
         return;

      var generateOverrides = AttributeHelper.GetAttributeArgumentValue(nexusConfigAttribute, 0, "generateEquality");
      if (generateOverrides is not true)
         return;

      var c = classSymbol.Name;
      var classType = classSymbol.ToDisplayString();

      builder.AppendLine();
      builder.AppendLine("# region Nexus Object Overrides");
      builder.AppendLine();

      // ToString override
      builder.AppendLine("    public override string ToString()");
      builder.AppendLine("    {");
      builder.AppendLine($"        return _getValue({c}.Field.UniqueId)?.ToString() ?? $\"{c} (no UniqueId)\";");
      builder.AppendLine("    }");
      builder.AppendLine();

      // Equals override
      builder.AppendLine("    public override bool Equals(object? obj)");
      builder.AppendLine("    {");
      builder.AppendLine($"        if (obj is not {c} other)");
      builder.AppendLine("            return false;");
      builder.AppendLine($"        return EqualityComparer<{classType}?>.Equals(_getValue({c}.Field.UniqueId), other._getValue({c}.Field.UniqueId));");
      builder.AppendLine("    }");
      builder.AppendLine();

      builder.AppendLine($"    public bool Equals({classType}? other)");
      builder.AppendLine("    {");
      builder.AppendLine("        if (other is null)");
      builder.AppendLine("            return false;");
      builder.AppendLine($"        return EqualityComparer<{classType}?>.Equals(_getValue({c}.Field.UniqueId), other._getValue({c}.Field.UniqueId));");
      builder.AppendLine("    }");
      builder.AppendLine();

      // GetHashCode override
      builder.AppendLine("    public override int GetHashCode()");
      builder.AppendLine("    {");
      builder.AppendLine($"        return _getValue({c}.Field.UniqueId).GetHashCode() ^ typeof({classType}).GetHashCode();");
      builder.AppendLine("    }");
      builder.AppendLine();

      // == and != operators
      builder.AppendLine($"    public static bool operator ==({classType}? left, {classType}? right)");
      builder.AppendLine("    {");
      builder.AppendLine("        if (left is null && right is null)");
      builder.AppendLine("            return true;");
      builder.AppendLine("        if (left is null || right is null)");
      builder.AppendLine("            return false;");
      builder.AppendLine("        return left.Equals(right);");
      builder.AppendLine("    }");
      builder.AppendLine();

      builder.AppendLine($"    public static bool operator !=({classType}? left, {classType}? right)");
      builder.AppendLine("    {");
      builder.AppendLine("        return !(left == right);");
      builder.AppendLine("    }");
      builder.AppendLine();

      builder.AppendLine("# endregion");
      builder.AppendLine();
   }

   /// <summary>
   /// Generate the Min and Max method calls which contains a switch over all properties to get their min/max values.
   /// </summary>
   public static void AppendMinMax(StringBuilder sb, List<PropertyConfigData?> propConfig)
   {
      sb.AppendLine("# region Min/Max Value Accessors");
      sb.AppendLine();
      sb.AppendLine("    public T? GetMinValue<T>(Enum property)");
      sb.AppendLine("    {");
      sb.AppendLine("        Debug.Assert(_getValue(property).GetType() == typeof(T));");
      sb.AppendLine("        return (T?)GetMinValue(property);");
      sb.AppendLine("    }");
      sb.AppendLine();

      // --- GetMinValue ---
      sb.AppendLine("    public object? GetMinValue(Enum property)");
      sb.AppendLine("    {");
      sb.AppendLine("        switch (property)");
      sb.AppendLine("        {");
      for (var i = 0; i < propConfig.Count; i++)
      {
         var config = propConfig[i];
         if (config?.MinValue is "null" or null)
            continue;

         sb.AppendLine($"            case Field.{config.PropertyName}:");
         sb.AppendLine($"                return {config.MinValue};");
      }

      sb.AppendLine("            default:");
      sb.AppendLine("                return null;");
      sb.AppendLine("        }");
      sb.AppendLine("    }");
      sb.AppendLine();

      // --- GetMaxValue ---
      sb.AppendLine("    public T? GetMaxValue<T>(Enum property)");
      sb.AppendLine("    {");
      sb.AppendLine("        Debug.Assert(_getValue(property).GetType() == typeof(T));");
      sb.AppendLine("        return (T?)GetMaxValue(property);");
      sb.AppendLine("    }");
      sb.AppendLine();

      sb.AppendLine("    public object? GetMaxValue(Enum property)");
      sb.AppendLine("    {");
      sb.AppendLine("        switch (property)");
      sb.AppendLine("        {");
      for (var i = 0; i < propConfig.Count; i++)
      {
         var config = propConfig[i];
         if (config?.MaxValue is "null" or null)
            continue;

         sb.AppendLine($"            case Field.{config.PropertyName}:");
         sb.AppendLine($"                return {config.MaxValue};");
      }

      sb.AppendLine("            default:");
      sb.AppendLine("                return null;");
      sb.AppendLine("        }");
      sb.AppendLine("    }");
      sb.AppendLine();
      sb.AppendLine("# endregion");
      sb.AppendLine();
   }

   private static void AppendIntBitsAsBools(StringBuilder sb, List<PropertyConfigData?> nuiConfig)
   {
      var bitArrays = new int[nuiConfig.Count];
      for (var i = 0; i < nuiConfig.Count; i++)
      {
         var data = nuiConfig[i];
         bitArrays[i] = 0;

         if (data == null)
            continue;

         bitArrays[i] |= data.IsInlined ? 1 << 0 : 0;
         bitArrays[i] |= data.IsReadonly ? 1 << 1 : 0;
         bitArrays[i] |= data.AllowEmpty ? 1 << 2 : 0;
         bitArrays[i] |= data.DisableMapInferButtons ? 1 << 3 : 0;
         bitArrays[i] |= data.IsRequired ? 1 << 4 : 0;
      }

      sb.AppendLine($"    /// <summary>");
      sb.AppendLine($"    /// Encoded NuiConfig data as an integer for efficient access. <br/>");
      sb.AppendLine($"    /// Bit 0: IsInlined <br/>");
      sb.AppendLine($"    /// Bit 1: IsReadOnly <br/>");
      sb.AppendLine($"    /// Bit 2: AllowEmpty <br/>");
      sb.AppendLine($"    /// Bit 3: DisableMapInferButtons <br/>");
      sb.AppendLine($"    /// Bit 4: IsRequired <br/>");
      sb.AppendLine($"    /// </summary>");
      // the int[] in binary format for easier debugging
      var arrayInitializer = string.Join(", ",
                                         bitArrays.Select(b => "0b" + Convert.ToString(b, 2).PadLeft(8, '0')));
      sb.AppendLine($"    private static readonly int[] _nuiConfigBits = {{ {arrayInitializer} }};");
      sb.AppendLine();

      // Write consts for access to the sb
      sb.AppendLine("    private const int IS_INLINED = 1 << 0;");
      sb.AppendLine("    private const int IS_READONLY = 1 << 1;");
      sb.AppendLine("    private const int ALLOW_EMPTY = 1 << 2;");
      sb.AppendLine("    private const int DISABLE_MAP_INFER_BUTTONS = 1 << 3;");
      sb.AppendLine("    private const int IS_REQUIRED = 1 << 4;");

      sb.AppendLine();

      // Generate methods to access the bits
      sb.AppendLine("    /// <summary>");
      sb.AppendLine("    /// Checks if the property is marked as inlined.");
      sb.AppendLine("    /// </summary>");
      sb.AppendLine("    public bool IsPropertyInlined(Enum property)");
      sb.AppendLine("        => (_nuiConfigBits[(int)((Field)property)] & IS_INLINED) != 0;");
      sb.AppendLine();

      sb.AppendLine("    /// <summary>");
      sb.AppendLine("    /// Checks if the property is marked as read-only.");
      sb.AppendLine("    /// </summary>");
      sb.AppendLine("    public bool IsPropertyReadOnly(Enum property)");
      sb.AppendLine("        => (_nuiConfigBits[(int)((Field)property)] & IS_READONLY) != 0;");
      sb.AppendLine();

      sb.AppendLine("    /// <summary>");
      sb.AppendLine("    /// Checks if the property allows empty values.");
      sb.AppendLine("    /// </summary>");
      sb.AppendLine("    public bool AllowsEmptyValue(Enum property)");
      sb.AppendLine("        => (_nuiConfigBits[(int)((Field)property)] & ALLOW_EMPTY) != 0;");
      sb.AppendLine();

      sb.AppendLine("    /// <summary>");
      sb.AppendLine("    /// Checks if the property has map infer buttons disabled.");
      sb.AppendLine("    /// </summary>");
      sb.AppendLine("    public bool IsMapInferButtonsDisabled(Enum property)");
      sb.AppendLine("        => (_nuiConfigBits[(int)((Field)property)] & DISABLE_MAP_INFER_BUTTONS) != 0;");
      sb.AppendLine();

      sb.AppendLine("    /// <summary>");
      sb.AppendLine("    /// Checks if the property is marked as required.");
      sb.AppendLine("    /// </summary>");
      sb.AppendLine("    public bool IsRequired(Enum property)");
      sb.AppendLine("        => (_nuiConfigBits[(int)((Field)property)] & IS_REQUIRED) != 0;");
      sb.AppendLine();
   }

   private static NuiConfigData? GetNuiConfigData(ISymbol member)
   {
      var attributes = member.GetAttributes();
      var nuiConfigAttribute = attributes
        .FirstOrDefault(ad => ad.AttributeClass?.ToDisplayString() ==
                              NUI_CONFIG_ATTRIBUTE_NAME);

      if (nuiConfigAttribute == null)
         return null;

      var nuiConfigData = new NuiConfigData
      {
         IsReadOnly = AttributeHelper.SimpleGetAttrArgValue<bool>(nuiConfigAttribute, 0, "isReadOnly"),
         IsInlined = AttributeHelper.SimpleGetAttrArgValue<bool>(nuiConfigAttribute, 1, "isInlined"),
         AllowEmpty = AttributeHelper.SimpleGetAttrArgValue<bool>(nuiConfigAttribute, 2, "allowEmpty"),
         DisableMapInferButtons = AttributeHelper.SimpleGetAttrArgValue<bool>(nuiConfigAttribute,
                                                                              3,
                                                                              "disableMapInferButtons"),
      };

      return nuiConfigData;
   }

   private static void AppendDefaultValues(StringBuilder builder,
                                           INamedTypeSymbol classSymbol,
                                           List<ISymbol> members,
                                           INamedTypeSymbol enumerableSymbol,
                                           INamedTypeSymbol ieu5ObjectSymbol,
                                           SourceProductionContext context)
   {
      // For each property we are going to look at the attributes including inheritance if it is marked with [DefaultValue]
      // if it does not exist we set it to null.
      // if it is null for a collection we set it to an empty collection of the right type.
      // if it is null for an object of the IEu5Object type we set it to it's empty value.
      var defaultValues = new List<string>();
      foreach (var member in members)
      {
         if (member is not IPropertySymbol propertySymbol)
         {
            defaultValues.Add("null");
            continue;
         }

         var defaultValueAttribute =
            Helpers.GetEffectiveAttribute(classSymbol, propertySymbol, "System.ComponentModel.DefaultValueAttribute");
         if (defaultValueAttribute is not { ConstructorArguments.Length: 1 })
         {
            defaultValues.Add("CAN_NOT_DETERMINE_DEFAULT_VALUE");
            // add a warning here
            context.ReportDiagnostic(Diagnostic.Create(new("NEXUSGEN002",
                                                           "Missing or invalid DefaultValue attribute",
                                                           $"Property '{propertySymbol.Name}' is missing a DefaultValue attribute or it is invalid. The default value will be set to null.",
                                                           "NexusGenerator",
                                                           DiagnosticSeverity.Warning,
                                                           true),
                                                       Location.None));
            continue;
         }

         var arg = defaultValueAttribute.ConstructorArguments[0];
         defaultValues.Add(PropertyConfigHelper.GenerateDefaultValue(ieu5ObjectSymbol, arg, propertySymbol));
      }

      // --- Generate a public accessor method for the default value ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Gets the default value of a property, if any.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public object GetDefaultValue(Enum property)");
      builder.AppendLine("    {");
      // a switch to return the value
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      for (var i = 0; i < members.Count; i++)
      {
         var member = members[i];
         var defaultValue = defaultValues[i];
         builder.AppendLine($"            case Field.{member.Name}:");
         if (defaultValue != "CAN_NOT_DETERMINE_DEFAULT_VALUE")
            builder.AppendLine($"                return {defaultValue};");
         else
            builder.AppendLine("                return ; // Default value could not be determined");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new ArgumentOutOfRangeException(nameof(property));");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();
      // --- Generate a public generic accessor method for the default value ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Gets the default value of a property, if any, casted to the specified type.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public T GetDefaultValue<T>(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        return (T)GetDefaultValue(property);");
      builder.AppendLine("    }");
      builder.AppendLine();
   }

   public struct NuiConfigData(bool isReadOnly, bool isInlined, bool allowEmpty, bool disableMapInferButtons)
   {
      public bool IsReadOnly = isReadOnly;
      public bool IsInlined = isInlined;
      public bool AllowEmpty = allowEmpty;
      public bool DisableMapInferButtons = disableMapInferButtons;
   }
}