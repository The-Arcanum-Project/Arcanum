using System.Globalization;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ParserGenerator.HelperClasses;

public static class NexusHelpers
{
   private const string INEXUS_INTERFACE = "Nexus.Core.INexus";

   private const string NUI_CONFIG_ATTRIBUTE_NAME =
      "Arcanum.Core.CoreSystems.NUI.Attributes.NuiConfigAttribute";

   private const string DESCRIPTION_ATTRIBUTE_NAME = "System.ComponentModel.DescriptionAttribute";

   private const string REQUIRED_ATTRIBUTE_NAME = "Arcanum.Core.GameObjects.BaseTypes.RequiredAttribute";
   private const string IGNORE_REQUIRED_ATTRIBUTE_NAME = "Arcanum.Core.GameObjects.BaseTypes.IgnoreRequiredAttribute";

   private const string JOMINI_COLOR_TYPE = "Arcanum.Core.CoreSystems.Parsing.ParsingHelpers.ArcColor.JominiColor";

   /// <summary>
   /// This transform finds any class that implements INexus.
   /// It's the gatekeeper for both generation steps.
   /// </summary>
   public static INamedTypeSymbol? GetNexusClassSymbol(GeneratorSyntaxContext context, CancellationToken token)
   {
      var classDeclaration = (ClassDeclarationSyntax)context.Node;

      if (ModelExtensions.GetDeclaredSymbol(context.SemanticModel, classDeclaration, token) is INamedTypeSymbol
          classSymbol)
      {
         var nexusInterface = context.SemanticModel.Compilation.GetTypeByMetadataName(INEXUS_INTERFACE);
         if (nexusInterface != null &&
             classSymbol.AllInterfaces.Contains(nexusInterface, SymbolEqualityComparer.Default))
            return classSymbol;
      }

      return null;
   }

   public static void RunPropertyModifierGenerator(INamedTypeSymbol classSymbol,
                                                   SourceProductionContext context,
                                                   INamedTypeSymbol enumerableSymbol,
                                                   INamedTypeSymbol ieu5ObjectSymbol,
                                                   INamedTypeSymbol iListSymbol)
   {
      var sourceCode = GeneratePropertyModifierPart(classSymbol,
                                                    Helpers.FindModifiableMembers(classSymbol, context),
                                                    enumerableSymbol,
                                                    ieu5ObjectSymbol,
                                                    iListSymbol,
                                                    context);
      var hintName = $"{classSymbol.ContainingNamespace}.{classSymbol.Name}.PropertyModifier.g.cs";
      context.AddSource(hintName, sourceCode);
   }

   private static string GeneratePropertyModifierPart(INamedTypeSymbol classSymbol,
                                                      List<ISymbol> members,
                                                      INamedTypeSymbol enumerableSymbol,
                                                      INamedTypeSymbol ieu5ObjectSymbol,
                                                      INamedTypeSymbol iListSymbol,
                                                      SourceProductionContext context)
   {
      var nuiConfig = new List<NuiConfigData?>();
      var descriptions = new List<string?>();

      // List of all members that are a collection
      var collectionMembers = new List<ISymbol>();
      var listMembers = new List<ISymbol>();
      var propertyTypes = new List<ITypeSymbol>();
      var collectionItemTypes = new List<ITypeSymbol?>();

      var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
      var className = classSymbol.Name;

      var builder = new StringBuilder();
      builder.AppendLine("// <auto-generated/>");
      builder.AppendLine("#nullable enable");
      builder.AppendLine("using Nexus.Core;");
      builder.AppendLine("using Arcanum.Core.CoreSystems.CommandSystem;");
      builder.AppendLine("using System.Runtime.CompilerServices;");
      builder.AppendLine("using System.ComponentModel;");
      builder.AppendLine("using Arcanum.Core.Registry;");
      builder.AppendLine("using System.Diagnostics;");

      builder.AppendLine($"namespace {namespaceName};");
      builder.AppendLine();
      builder.AppendLine($"public partial class {className}");
      builder.AppendLine("{");

      // 1. Generate the Enum
      builder.AppendLine("    public enum Field");
      builder.AppendLine("    {");
      foreach (var member in members)
      {
         var memberType = member switch
         {
            IPropertySymbol p => p.Type,
            IFieldSymbol f => f.Type,
            _ => throw new ArgumentOutOfRangeException(),
         };

         propertyTypes.Add(memberType);

         nuiConfig.Add(GetNuiConfigData(member));

         // Gather the description (if any)
         var descriptionAttribute = member.GetAttributes()
                                          .FirstOrDefault(ad =>
                                                             string.Equals(ad.AttributeClass?.ToDisplayString(),
                                                                           DESCRIPTION_ATTRIBUTE_NAME,
                                                                           StringComparison.Ordinal));
         // ReSharper disable once MergeIntoPattern
         descriptions.Add(descriptionAttribute is null
                             ? null
                             : descriptionAttribute.ConstructorArguments.Length == 1 &&
                               descriptionAttribute.ConstructorArguments[0].Value is string desc
                                ? desc
                                : null);

         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         collectionItemTypes.Add(itemType);

         if (itemType != null)
         {
            collectionMembers.Add(member);
            // Check if it's a List
            if (memberType.AllInterfaces.Contains(iListSymbol, SymbolEqualityComparer.Default))
               listMembers.Add(member);
         }

         // 2. Get a fully qualified name for the type
         var memberTypeName = memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
         builder.AppendLine($"        [ExpectedType(typeof({memberTypeName}))]");
         builder.AppendLine($"        {member.Name},");
      }

      builder.AppendLine("    }");
      builder.AppendLine();

      AppendRequiredFilter(builder, classSymbol, members);

      AppendDefaultValues(builder, classSymbol, members, enumerableSymbol, ieu5ObjectSymbol, context);

      #region Property Modifiers and acessors

      builder.AppendLine("#region Property Modifier Backing Fields");
      builder.AppendLine();

      // -------- Description Array --------
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// A pre-generated array containing the description of each property, if any.");
      builder.AppendLine("    /// Accessed via the 'Field' enum index.");
      builder.AppendLine("    /// </summary>");

      var descriptionInitializer = string.Join(", ",
                                               descriptions.Select(s => s is null
                                                                           ? "null"
                                                                           : SymbolDisplay.FormatLiteral(s, true)));
      builder.AppendLine($"    private static readonly string?[] _descriptions = {{ {descriptionInitializer} }};");
      builder.AppendLine();

      // -------- Property Type Array --------
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// A pre-generated array containing the Type of each property.");
      builder.AppendLine("    /// Accessed via the 'Field' enum index.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine($"    private static readonly Type[] _propertyTypes =");
      builder.AppendLine("    {");
      foreach (var typeSymbol in propertyTypes)
      {
         var typeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
         builder.AppendLine($"        typeof({typeName}),");
      }

      builder.AppendLine("    };");
      builder.AppendLine();
      builder.AppendLine($"#endregion");
      builder.AppendLine();

      // -------- Collection Item Type Array --------
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// A pre-generated array containing the item Type for collection properties, or null otherwise.");
      builder.AppendLine("    /// Accessed via the 'Field' enum index.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine($"    private static readonly Type?[] _collectionItemTypes =");
      builder.AppendLine("    {");
      foreach (var typeSymbol in collectionItemTypes)
      {
         var typeString = typeSymbol == null
                             ? "null"
                             : $"typeof({typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})";

         builder.AppendLine($"        {typeString},");
      }

      builder.AppendLine("    };");
      builder.AppendLine();

      // ########## NUI CONFIG ##########
      builder.AppendLine();
      builder.AppendLine("#region NUI Config Accessors");

      AppendIntBitsAsBools(builder, nuiConfig);

      builder.AppendLine("#endregion");

      builder.AppendLine("#region Property Modifier Methods");
      builder.AppendLine();

      // --- Generate a public accessor method for the Description ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Gets the description of a property, if any.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public string? GetDescription(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        Debug.Assert(Enum.IsDefined(typeof(Field), property), \"Invalid property enum value\");");
      builder.AppendLine("        return _descriptions[(int)((Field)property)];");
      builder.AppendLine("    }");
      builder.AppendLine();

      builder.AppendLine("#endregion");
      builder.AppendLine();

      #endregion

      #region Get and Set Value methods

      // 2. Generate the SetValue method
      // with an on property changed call and a check if the value actually changed
      builder.AppendLine("    public void _setValue(Enum property, object value)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in members)
      {
         var memberType = member is IPropertySymbol p ? p.Type : ((IFieldSymbol)member).Type;
         var typeName = memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

         builder.AppendLine($"            case Field.{member.Name}:");
#if DEBUG
         builder.AppendLine($"                Debug.Assert(value is {typeName}, \"{member.Name} needs to be a {typeName}\");");
#endif
         if (collectionMembers.Contains(member))
         {
            var itemType = memberType.SpecialType == SpecialType.System_String
                              ? "string"
                              : (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault()?.ToDisplayString();
            builder.AppendLine($"                 if (this.{member.Name}.SequenceEqual((System.Collections.Generic.ICollection<{itemType}>)value))");
            builder.AppendLine("                 {");
            builder.AppendLine($"                     this.{member.Name} = ({typeName})value;");
            builder.AppendLine("                     OnPropertyChanged(nameof(this." + member.Name + "));");
            builder.AppendLine("                 }");
         }
         else
         {
            builder.AppendLine($"                if (!EqualityComparer<{typeName}>.Default.Equals(this.{member.Name}, ({typeName})value))");
            builder.AppendLine("                {");
            builder.AppendLine($"                    this.{member.Name} = ({typeName})value;");
            builder.AppendLine("                    OnPropertyChanged(nameof(this." + member.Name + "));");
            builder.AppendLine("                }");
         }

         builder.AppendLine("                break;");
      }

      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      builder.AppendLine("    public object _getValue(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in members)
      {
         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                return this.{member.Name};");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new ArgumentOutOfRangeException(nameof(property));");
      builder.AppendLine("        }");
      builder.AppendLine("    }");

      // --- Public accessor method for the Property Type ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Gets the Type of a property.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public Type GetNxPropType(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        Debug.Assert(Enum.IsDefined(typeof(Field), property), \"Invalid property enum value\");");
      builder.AppendLine("        return _propertyTypes[(int)((Field)property)];");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- Public accessor method for the Collection Item Type ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Gets the item Type for a collection property, or null if the property is not a collection.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public Type? GetNxItemType(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        Debug.Assert(Enum.IsDefined(typeof(Field), property), \"Invalid property enum value\");");
      builder.AppendLine("        return _collectionItemTypes[(int)((Field)property)];");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- IsCollection ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Checks if a property is a collection.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public bool IsCollection(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        Debug.Assert(Enum.IsDefined(typeof(Field), property), \"Invalid property enum value\");");
      builder.AppendLine("        return GetNxItemType(property) != null;");
      builder.AppendLine("    }");
      builder.AppendLine();

      #endregion

      #region Collection Manipulation Methods

      builder.AppendLine();
      builder.AppendLine("#region Collection Manipulation Methods");
      builder.AppendLine();

      // --- AddToCollection ---
      builder.AppendLine("    public void _addToCollection(Enum property, object item)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in collectionMembers)
      {
         var memberType = member is IPropertySymbol p ? p.Type : ((IFieldSymbol)member).Type;
         // Get the collection's item type, e.g., 'string' from 'ObservableRangeCollection<string>'
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                Debug.Assert(item is {itemTypeName}, \"Item needs to be a {itemTypeName}\");");
         builder.AppendLine($"                Debug.Assert(this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}>, \"Property '{member.Name}' is not a collection.\");");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}> {member.Name}_coll && item is {itemTypeName} {member.Name}_typedItem)");
         builder.AppendLine($"                    {member.Name}_coll.Add({member.Name}_typedItem);");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' is not a collection.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- RemoveFromCollection ---
      builder.AppendLine("    public void _removeFromCollection(Enum property, object item)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in collectionMembers)
      {
         var memberType = member is IPropertySymbol p ? p.Type : ((IFieldSymbol)member).Type;
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                Debug.Assert(item is {itemTypeName}, \"Item needs to be a {itemTypeName}\");");
         builder.AppendLine($"                Debug.Assert(this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}>, \"Property '{member.Name}' is not a collection.\");");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}> {member.Name}_coll && item is {itemTypeName} {member.Name}_typedItem)");
         builder.AppendLine($"                    {member.Name}_coll.Remove({member.Name}_typedItem);");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' is not a collection.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- ClearCollection ---
      builder.AppendLine("    public void _clearCollection(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in collectionMembers)
      {
         var memberType = (member is IPropertySymbol p) ? p.Type : ((IFieldSymbol)member).Type;
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                Debug.Assert(this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}>, \"Property '{member.Name}' is not a collection.\");");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}> {member.Name}_coll)");
         builder.AppendLine($"                    {member.Name}_coll.Clear();");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' is not a collection.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      builder.AppendLine("#endregion");
      builder.AppendLine();

      // --- InsertIntoCollection ---
      builder.AppendLine("    public void _insertIntoCollection(Enum property, int index, object item)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in listMembers)
      {
         var memberType = (member is IPropertySymbol p) ? p.Type : ((IFieldSymbol)member).Type;
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                Debug.Assert(item is {itemTypeName}, \"Item must be of type {itemTypeName}\");");
         builder.AppendLine($"                Debug.Assert(this.{member.Name} is System.Collections.Generic.IList<{itemTypeName}>, \"Property '{member.Name}' must be an IList to support InsertAt.\");");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.IList<{itemTypeName}> {member.Name}_list && item is {itemTypeName} {member.Name}_typedItem)");
         builder.AppendLine($"                    {member.Name}_list.Insert(index, {member.Name}_typedItem);");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' does not support indexed insertion.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- RemoveFromCollectionAt ---
      builder.AppendLine("    public void _removeFromCollectionAt(Enum property, int index)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in listMembers)
      {
         var memberType = (member is IPropertySymbol p) ? p.Type : ((IFieldSymbol)member).Type;
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                Debug.Assert(this.{member.Name} is System.Collections.Generic.IList<{itemTypeName}>, \"Property '{member.Name}' must be an IList to support RemoveAt.\");");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.IList<{itemTypeName}> {member.Name}_list)");
         builder.AppendLine($"                    {member.Name}_list.RemoveAt(index);");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' does not support indexed removal.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      // --- AddRangeToCollection (for Clear undo) ---
      builder.AppendLine("    public void _addRangeToCollection(Enum property, System.Collections.IEnumerable items)");
      builder.AppendLine("    {");
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      foreach (var member in collectionMembers)
      {
         var memberType = (member is IPropertySymbol p) ? p.Type : ((IFieldSymbol)member).Type;
         var itemType = (memberType as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
         var itemTypeName = itemType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

         builder.AppendLine($"            case Field.{member.Name}:");
         builder.AppendLine($"                if (this.{member.Name} is System.Collections.Generic.ICollection<{itemTypeName}> {member.Name}_coll)");
         builder.AppendLine("                {");
         builder.AppendLine("                    foreach (var item in items.Cast<object>().ToList())");
         builder.AppendLine($"                        {member.Name}_coll.Add(({itemTypeName})item);");
         builder.AppendLine("                }");
         builder.AppendLine("                break;");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new InvalidOperationException($\"Property '{property}' is not a collection.\");");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();

      #endregion

      #region Indexer

      // Indexer has to call those methods and not use faster _setValue or _getValue to ensure PropertyChanged is called
      builder.AppendLine();
      builder.AppendLine("    public object this[Enum key]");
      builder.AppendLine("    {");
      builder.AppendLine("        get {");
      builder.AppendLine("            object value = null!;");
      builder.AppendLine("            Nx.ForceGet(this, key, ref value);");
      builder.AppendLine("            return value;");
      builder.AppendLine("        }");
      builder.AppendLine("        set => Nx.ForceSet(value, this, key);");
      builder.AppendLine("    }");

      #endregion

      #region GetAllProperties

      builder.AppendLine();
      builder.AppendLine("    public List<Enum> GetAllProperties()");
      builder.AppendLine("    {");
      builder.AppendLine("        return Enum.GetValues(typeof(Field)).Cast<Enum>().ToList();");
      builder.AppendLine("    }");

      #endregion

      #region Property Changed

      builder.AppendLine();
      builder.AppendLine("#region INotifyPropertyChanged Implementation");
      builder.AppendLine();
      builder.AppendLine("    public event PropertyChangedEventHandler? PropertyChanged;");
      builder.AppendLine();
      builder.AppendLine("    protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)");
      builder.AppendLine("    {");
      builder.AppendLine("        PropertyChanged?.Invoke(this, new(propertyName));");
      builder.AppendLine("    }");
      builder.AppendLine();
      builder.AppendLine("    protected bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)");
      builder.AppendLine("    {");
      builder.AppendLine("        if (EqualityComparer<T>.Default.Equals(field, value))");
      builder.AppendLine("            return false;");
      builder.AppendLine();
      builder.AppendLine("        field = value;");
      builder.AppendLine("        OnPropertyChanged(propertyName);");
      builder.AppendLine("        return true;");
      builder.AppendLine("    }");
      builder.AppendLine();
      builder.AppendLine("#endregion");
      builder.AppendLine();

      #endregion

      builder.AppendLine("}"); // Close class

      return builder.ToString();
   }

   private static void AppendIntBitsAsBools(StringBuilder sb, List<NuiConfigData?> nuiConfig)
   {
      var bitArrays = new int[nuiConfig.Count];
      for (var i = 0; i < nuiConfig.Count; i++)
      {
         var dataNull = nuiConfig[i];
         bitArrays[i] = 0;

         if (!dataNull.HasValue)
            continue;

         var data = dataNull.Value;
         bitArrays[i] |= data.IsInlined ? 1 << 0 : 0;
         bitArrays[i] |= data.IsReadOnly ? 1 << 1 : 0;
         bitArrays[i] |= data.AllowEmpty ? 1 << 2 : 0;
         bitArrays[i] |= data.DisableMapInferButtons ? 1 << 3 : 0;
      }

      sb.AppendLine($"    /// <summary>");
      sb.AppendLine($"    /// Encoded NuiConfig data as an integer for efficient access. <br/>");
      sb.AppendLine($"    /// Bit 0: IsInlined <br/>");
      sb.AppendLine($"    /// Bit 1: IsReadOnly <br/>");
      sb.AppendLine($"    /// Bit 2: AllowEmpty <br/>");
      sb.AppendLine($"    /// Bit 3: DisableMapInferButtons <br/>");
      sb.AppendLine($"    /// </summary>");
      // the int[] in binary format for easier debugging
      var arrayInitializer = string.Join(", ",
                                         bitArrays.Select(b => "0b" + Convert.ToString(b, 2).PadLeft(8, '0')));
      sb.AppendLine($"    private static readonly int[] _nuiConfigBits = {{ {arrayInitializer} }};");
      sb.AppendLine();

      // Write consts for access to the sb
      sb.AppendLine("    private const int IS_INLINED = 1 << 0;");
      sb.AppendLine("    private const int IS_READONLY = 1 << 1;");
      sb.AppendLine("    private const int ALLOW_EMPTY = 1 << 2;");
      sb.AppendLine("    private const int DISABLE_MAP_INFER_BUTTONS = 1 << 3;");

      sb.AppendLine();

      // Generate methods to access the bits
      sb.AppendLine("    /// <summary>");
      sb.AppendLine("    /// Checks if the property is marked as inlined.");
      sb.AppendLine("    /// </summary>");
      sb.AppendLine("    public bool IsPropertyInlined(Enum property)");
      sb.AppendLine("        => (_nuiConfigBits[(int)((Field)property)] & IS_INLINED) != 0;");
      sb.AppendLine();

      sb.AppendLine("    /// <summary>");
      sb.AppendLine("    /// Checks if the property is marked as read-only.");
      sb.AppendLine("    /// </summary>");
      sb.AppendLine("    public bool IsPropertyReadOnly(Enum property)");
      sb.AppendLine("        => (_nuiConfigBits[(int)((Field)property)] & IS_READONLY) != 0;");
      sb.AppendLine();

      sb.AppendLine("    /// <summary>");
      sb.AppendLine("    /// Checks if the property allows empty values.");
      sb.AppendLine("    /// </summary>");
      sb.AppendLine("    public bool AllowsEmptyValue(Enum property)");
      sb.AppendLine("        => (_nuiConfigBits[(int)((Field)property)] & ALLOW_EMPTY) != 0;");
      sb.AppendLine();

      sb.AppendLine("    /// <summary>");
      sb.AppendLine("    /// Checks if the property has map infer buttons disabled.");
      sb.AppendLine("    /// </summary>");
      sb.AppendLine("    public bool IsMapInferButtonsDisabled(Enum property)");
      sb.AppendLine("        => (_nuiConfigBits[(int)((Field)property)] & DISABLE_MAP_INFER_BUTTONS) != 0;");
      sb.AppendLine();
   }

   private static NuiConfigData? GetNuiConfigData(ISymbol member)
   {
      var attributes = member.GetAttributes();
      var nuiConfigAttribute = attributes
        .FirstOrDefault(ad => ad.AttributeClass?.ToDisplayString() ==
                              NUI_CONFIG_ATTRIBUTE_NAME);

      if (nuiConfigAttribute == null)
         return null;

      var nuiConfigData = new NuiConfigData
      {
         IsReadOnly = AttributeHelper.SimpleGetAttributeArgumentValue<bool>(nuiConfigAttribute, 0, "isReadOnly"),
         IsInlined = AttributeHelper.SimpleGetAttributeArgumentValue<bool>(nuiConfigAttribute, 1, "isInlined"),
         AllowEmpty = AttributeHelper.SimpleGetAttributeArgumentValue<bool>(nuiConfigAttribute, 2, "allowEmpty"),
         DisableMapInferButtons = AttributeHelper.SimpleGetAttributeArgumentValue<bool>(nuiConfigAttribute,
          3,
          "disableMapInferButtons"),
      };

      return nuiConfigData;
   }

   private static void AppendRequiredFilter(StringBuilder builder, INamedTypeSymbol classSymbol, List<ISymbol> members)
   {
      // For each property we are going to look at the attributes including inheritance if it is marked with [Required]
      // or if the [Required] attribute is overridden with [IgnoreRequired] in a derived class
      var requiredProperties = new List<bool>();
      foreach (var member in members)
      {
         if (member is not IPropertySymbol propertySymbol)
            continue;

         var requiredAttribute = Helpers.GetEffectiveAttribute(classSymbol, propertySymbol, REQUIRED_ATTRIBUTE_NAME);
         var ignoreRequiredAttribute =
            Helpers.GetEffectiveAttribute(classSymbol, propertySymbol, IGNORE_REQUIRED_ATTRIBUTE_NAME);

         requiredProperties.Add(requiredAttribute != null && ignoreRequiredAttribute == null);
      }

      // ------- Required Property Array -------
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// A pre-generated array indicating whether a property is required.");
      builder.AppendLine("    /// Accessed via the 'Field' enum index.");
      builder.AppendLine("    /// </summary>");

      var arrayInitializer = string.Join(", ", requiredProperties.Select(s => s.ToString().ToLower()));
      builder.AppendLine($"    private static readonly bool[] _isRequired = {{ {arrayInitializer} }};");
      builder.AppendLine();

      // --- Generate a public accessor method for the required status ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Checks if a property is marked as required.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public bool IsRequired(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        Debug.Assert(Enum.IsDefined(typeof(Field), property), \"Invalid property enum value\");");
      builder.AppendLine("        return _isRequired[(int)((Field)property)];");
      builder.AppendLine("    }");
      builder.AppendLine();
   }

   private static void AppendDefaultValues(StringBuilder builder,
                                           INamedTypeSymbol classSymbol,
                                           List<ISymbol> members,
                                           INamedTypeSymbol enumerableSymbol,
                                           INamedTypeSymbol ieu5ObjectSymbol,
                                           SourceProductionContext context)
   {
      // For each property we are going to look at the attributes including inheritance if it is marked with [DefaultValue]
      // if it does not exist we set it to null.
      // if it is null for a collection we set it to an empty collection of the right type.
      // if it is null for an object of the IEu5Object type we set it to it's empty value.
      var defaultValues = new List<string>();
      foreach (var member in members)
      {
         if (member is not IPropertySymbol propertySymbol)
         {
            defaultValues.Add("null");
            continue;
         }

         var defaultValueAttribute =
            Helpers.GetEffectiveAttribute(classSymbol, propertySymbol, "System.ComponentModel.DefaultValueAttribute");
         if (defaultValueAttribute is not { ConstructorArguments.Length: 1 })
         {
            defaultValues.Add("CAN_NOT_DETERMINE_DEFAULT_VALUE");
            // add a warning here
            context.ReportDiagnostic(Diagnostic.Create(new("NEXUSGEN002",
                                                           "Missing or invalid DefaultValue attribute",
                                                           $"Property '{propertySymbol.Name}' is missing a DefaultValue attribute or it is invalid. The default value will be set to null.",
                                                           "NexusGenerator",
                                                           DiagnosticSeverity.Warning,
                                                           true),
                                                       Location.None));
            continue;
         }

         var arg = defaultValueAttribute.ConstructorArguments[0];
         if (arg.Value == null)
         {
            // If the value is null we need to check the type of the property
            var propertyType = propertySymbol.Type;
            if (propertyType.TypeKind is TypeKind.Class or TypeKind.Interface)
            {
               // We have to check if it is of the ieu5ObjectSymbol type
               if (ieu5ObjectSymbol != null &&
                   propertyType.AllInterfaces.Contains(ieu5ObjectSymbol,
                                                       SymbolEqualityComparer.Default))
               {
                  // For IEu5Object types we get the empty value from the registry
                  var typeName = propertyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                  defaultValues.Add($"EmptyRegistry.Empties[typeof({typeName})]");
               }
               else if (Helpers.IsGenericCollection(propertyType, out _))
               {
                  var fullCollectionTypeName = propertyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                  defaultValues.Add($"new {fullCollectionTypeName}()");
               }
               // Check if we have a JominiColor
               else if (propertyType.ToDisplayString() == JOMINI_COLOR_TYPE)
               {
                  defaultValues.Add($"global::{JOMINI_COLOR_TYPE}.Empty");
               }
               else
               {
                  // For reference types we can just use null
                  defaultValues.Add("null!");
               }
            }
            else
            {
               // For other value types we use the default literal
               var typeName = propertyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
               defaultValues.Add($"default({typeName})");
            }
         }
         else if (arg.Type != null)
         {
            if (propertySymbol.Type.BaseType?.ToDisplayString() == "System.Enum")
            {
               var enumTypeName = propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
               var enumValue = arg.Value?.ToString() ?? "0";

               defaultValues.Add($"({enumTypeName}){enumValue}");
               continue;
            }

            // We have to format the value based on its type
            var formattedValue = arg.Type.SpecialType switch
            {
               SpecialType.System_String => SymbolDisplay.FormatLiteral(arg.Value?.ToString() ?? "string.Empty", true),
               SpecialType.System_Char => SymbolDisplay.FormatLiteral((char)(arg.Value ?? '\0'), true),
               SpecialType.System_Boolean => arg.Value?.ToString()?.ToLower() ?? "false",
               SpecialType.System_Single => ((float?)arg.Value)?.ToString("R", CultureInfo.InvariantCulture) + "f",
               SpecialType.System_Double => ((double?)arg.Value)?.ToString("R", CultureInfo.InvariantCulture) + "d",
               SpecialType.System_Decimal => ((decimal?)arg.Value)?.ToString(CultureInfo.InvariantCulture) + "m",
               SpecialType.System_Int64 => $"{arg.Value}L",
               SpecialType.System_UInt64 => $"{arg.Value}UL",
               SpecialType.System_Int32
               or SpecialType.System_UInt32
               or SpecialType.System_Int16
               or SpecialType.System_UInt16
               or SpecialType.System_Byte
               or SpecialType.System_SByte => arg.Value?.ToString() ?? "0",
               _ => arg.Value != null
                       ? $"({arg.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}){arg.Value}"
                       : "null",
            };
            if (arg.Type.SpecialType == SpecialType.System_String &&
                string.IsNullOrWhiteSpace(formattedValue.Substring(1, formattedValue.Length - 2)))
               formattedValue = "string.Empty";
            defaultValues.Add(formattedValue);
         }
         else
         {
            defaultValues.Add("null");
         }
      }

      // --- Generate a public accessor method for the default value ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Gets the default value of a property, if any.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public object GetDefaultValue(Enum property)");
      builder.AppendLine("    {");
      // a switch to return the value
      builder.AppendLine("        switch (property)");
      builder.AppendLine("        {");
      for (var i = 0; i < members.Count; i++)
      {
         var member = members[i];
         var defaultValue = defaultValues[i];
         builder.AppendLine($"            case Field.{member.Name}:");
         if (defaultValue != "CAN_NOT_DETERMINE_DEFAULT_VALUE")
            builder.AppendLine($"                return {defaultValue};");
         else
            builder.AppendLine("                return ; // Default value could not be determined");
      }

      builder.AppendLine("            default:");
      builder.AppendLine("                throw new ArgumentOutOfRangeException(nameof(property));");
      builder.AppendLine("        }");
      builder.AppendLine("    }");
      builder.AppendLine();
      // --- Generate a public generic accessor method for the default value ---
      builder.AppendLine("    /// <summary>");
      builder.AppendLine("    /// Gets the default value of a property, if any, casted to the specified type.");
      builder.AppendLine("    /// </summary>");
      builder.AppendLine("    public T GetDefaultValue<T>(Enum property)");
      builder.AppendLine("    {");
      builder.AppendLine("        return (T)GetDefaultValue(property);");
      builder.AppendLine("    }");
      builder.AppendLine();
   }

   public struct NuiConfigData(bool isReadOnly, bool isInlined, bool allowEmpty, bool disableMapInferButtons)
   {
      public bool IsReadOnly = isReadOnly;
      public bool IsInlined = isInlined;
      public bool AllowEmpty = allowEmpty;
      public bool DisableMapInferButtons = disableMapInferButtons;
   }
}