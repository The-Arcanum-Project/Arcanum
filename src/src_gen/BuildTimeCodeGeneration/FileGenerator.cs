using System.IO;
using System.Text;

namespace BuildTimeCodeGeneration;

public static class FileGenerator
{
   public static void GenerateEffectsTriggerFile(List<EffectTriggerObj> definitions,
                                                 string outputPath,
                                                 string className)
   {
      var sb = new StringBuilder();
      sb.AppendLine("// <auto-generated>");
      sb.AppendLine("//     This code was generated by a tool. Do not edit manually.");
      sb.AppendLine("// </auto-generated>");
      sb.AppendLine();
      sb.AppendLine("using System;");
      sb.AppendLine("using System.Collections.Generic;");
      sb.AppendLine("using Arcanum.Core.CoreSystems.Jomini.Scopes;");
      sb.AppendLine();
      sb.AppendLine("namespace Arcanum.Core.CoreSystems.Jomini.Effects");
      sb.AppendLine("{");

      // Generate the static data holder class
      sb.AppendLine($"    public static class {className}Registry");
      sb.AppendLine("    {");
      sb.AppendLine($"        public static readonly IReadOnlyDictionary<string, ETDefinition> Registry = new Dictionary<string, ETDefinition>");
      sb.AppendLine("        {");
      foreach (var def in definitions)
      {
         // The dictionary initializer uses { Key, Value } syntax
         sb.AppendLine($"            {{");
         sb.AppendLine($"                \"{def.Name}\",");
         sb.AppendLine($"                new ETDefinition(");
         sb.AppendLine($"                    name: \"{def.Name}\",");
         sb.AppendLine($"                    description: @\"{def.Description.Replace("\"", "\"\"")}\",");
         sb.AppendLine($"                    usage: @\"{def.Usage.Replace("\"", "\"\"")}\",");
         sb.AppendLine($"                    readsGameStateForAllScopes: {def.ReadsGameStateForAllScopes.ToString().ToLower()},");
         sb.AppendLine($"                    traits: new List<string> {{ {string.Join(", ", def.Traits.Select(t => $"\"{t.Trim()}\""))} }},");
         sb.AppendLine($"                    scopes: new ScopeType[] {{ {string.Join(", ", def.Scopes.Select(s => $"ScopeType.{s}"))} }},");
         sb.AppendLine($"                    targets: new ScopeType[] {{ {string.Join(", ", def.Targets.Select(t => $"ScopeType.{t}"))} }}");
         sb.AppendLine($"                )");
         sb.AppendLine($"            }},");
      }

      sb.AppendLine("        };");
      sb.AppendLine("    }");
      sb.AppendLine("}");

      File.WriteAllText(outputPath, sb.ToString());
   }

   public static void GenerateScopesFile(HashSet<ScopeDefinition> definitions, string outputPath)
   {
      var sb = new StringBuilder();
      sb.AppendLine("// <auto-generated>");
      sb.AppendLine("//     This code was generated by a tool. Do not edit manually.");
      sb.AppendLine("// </auto-generated>");
      sb.AppendLine();
      sb.AppendLine("using System;");
      sb.AppendLine("using System.Collections.Generic;");
      sb.AppendLine();
      sb.AppendLine("namespace Arcanum.Core.CoreSystems.Jomini.Scopes");
      sb.AppendLine("{");

      // Generate the ScopeType enum
      sb.AppendLine("    public enum ScopeType");
      sb.AppendLine("    {");
      foreach (var value in Enum.GetValues(typeof(ScopeType)).Cast<ScopeType>())
         sb.AppendLine($"        {value} = {(int)value},");
      sb.AppendLine("    }");
      sb.AppendLine();

      if (DocumentationParser.UnknowScopeTypes.Count > 0)
      {
         sb.AppendLine("    // NOTE: The following scope types were found in the documentation but are not defined in the ScopeType enum:");
         foreach (var unknown in DocumentationParser.UnknowScopeTypes)
            sb.AppendLine($"    // - {unknown}");
         sb.AppendLine();
      }

      // Generate the EffectTriggerObj class
      sb.AppendLine($"    public class ETDefinition");
      sb.AppendLine("    {");
      sb.AppendLine("        public string Name { get; }");
      sb.AppendLine("        public string Description { get; }");
      sb.AppendLine("        public string Usage { get; }");
      sb.AppendLine("        public bool ReadsGameStateForAllScopes { get; }");
      sb.AppendLine("        public IReadOnlyList<string> Traits { get; }");
      sb.AppendLine("        public ScopeType[] Scopes { get; }");
      sb.AppendLine("        public ScopeType[] Targets { get; }");
      sb.AppendLine();
      sb.AppendLine($"        public ETDefinition(string name, string description, string usage, bool readsGameStateForAllScopes, IReadOnlyList<string> traits, ScopeType[] scopes, ScopeType[] targets)");
      sb.AppendLine("        {");
      sb.AppendLine("            Name = name;");
      sb.AppendLine("            Description = description;");
      sb.AppendLine("            Usage = usage;");
      sb.AppendLine("            ReadsGameStateForAllScopes = readsGameStateForAllScopes;");
      sb.AppendLine("            Traits = traits;");
      sb.AppendLine("            Scopes = scopes;");
      sb.AppendLine("            Targets = targets;");
      sb.AppendLine("        }");
      sb.AppendLine("    }");
      sb.AppendLine();

      // Generate the ScopeDefinition class
      sb.AppendLine("    public class ScopeDefinition");
      sb.AppendLine("    {");
      sb.AppendLine("        public string Key { get; }");
      sb.AppendLine("        public string Description { get; }");
      sb.AppendLine("        public bool RequiresData { get; }");
      sb.AppendLine("        public IReadOnlySet<ScopeType> InputType { get; }");
      sb.AppendLine("        public IReadOnlySet<ScopeType> OutputType { get; }");
      sb.AppendLine();
      sb.AppendLine("        public ScopeDefinition(string key, string description, bool requiresData, IReadOnlySet<ScopeType> inputType, IReadOnlySet<ScopeType> outputType)");
      sb.AppendLine("        {");
      sb.AppendLine("            Key = key;");
      sb.AppendLine("            Description = description;");
      sb.AppendLine("            RequiresData = requiresData;");
      sb.AppendLine("            InputType = inputType;");
      sb.AppendLine("            OutputType = outputType;");
      sb.AppendLine("        }");
      sb.AppendLine("    }");
      sb.AppendLine();

      // Generate the static registry class
      sb.AppendLine("    public static class ScopeRegistry");
      sb.AppendLine("    {");
      sb.AppendLine("        /// <summary>");
      sb.AppendLine("        /// Registry of all scope definitions parsed from documentation.");
      sb.AppendLine("        /// </summary>");
      sb.AppendLine("        public static readonly IReadOnlyDictionary<string, ScopeDefinition> Registry = new Dictionary<string, ScopeDefinition>");
      sb.AppendLine("        {");

      foreach (var def in definitions)
      {
         // The dictionary initializer uses { Key, Value } syntax
         sb.AppendLine($"            {{");
         sb.AppendLine($"                \"{def.Key}\",");
         sb.AppendLine($"                new ScopeDefinition(");
         sb.AppendLine($"                    key: \"{def.Key}\",");
         sb.AppendLine($"                    description: @\"{def.Description.Replace("\"", "\"\"")}\",");
         sb.AppendLine($"                    requiresData: {def.RequiresData.ToString().ToLower()},");
         sb.AppendLine($"                    inputType: {FormatScopeSet(def.InputType)},");
         sb.AppendLine($"                    outputType: {FormatScopeSet(def.OutputType)}");
         sb.AppendLine($"                )");
         sb.AppendLine($"            }},");
      }

      sb.AppendLine("        };");
      sb.AppendLine("    }");
      sb.AppendLine("}");

      File.WriteAllText(outputPath, sb.ToString());
   }

   private static string FormatScopeSet(IReadOnlySet<ScopeType> scopes)
   {
      if (scopes == null! || scopes.Count == 0)
         return "new HashSet<ScopeType>()";

      var scopeStrings = scopes.Select(s => $"ScopeType.{s}");
      return $"new HashSet<ScopeType> {{ {string.Join(", ", scopeStrings)} }}";
   }
}