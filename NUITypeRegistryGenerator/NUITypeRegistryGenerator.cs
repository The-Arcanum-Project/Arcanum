// using System.Collections.Immutable;
// using System.Text;
// using Microsoft.CodeAnalysis;
// using Microsoft.CodeAnalysis.CSharp.Syntax;
// using Microsoft.CodeAnalysis.Text;
//
// namespace NUITypeRegistryGenerator;
//
// [Generator]
// public class NUITypeRegistryGenerator : IIncrementalGenerator
// {
//    private const string INUI_TYPE_NAME =
//       "Arcanum.Core.CoreSystems.NUI.INUI"; // IMPORTANT: Use the fully qualified name of your INUI interface
//
//    public void Initialize(IncrementalGeneratorInitializationContext context)
//    {
//       // 1. Find all class declarations that are not abstract
//       var classDeclarations = context.SyntaxProvider
//                                      .CreateSyntaxProvider(predicate: static (s, _)
//                                                               => s is ClassDeclarationSyntax cds &&
//                                                                  !cds.Modifiers.Any(m => m.IsKind(Microsoft.CodeAnalysis
//                                                                    .CSharp.SyntaxKind.AbstractKeyword)),
//                                                            transform: static (ctx, _)
//                                                               => (ClassDeclarationSyntax)ctx.Node)
//                                      .Where(static c => c is not null);
//
//       // 2. Combine with compilation to get semantic symbols
//       IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
//          context.CompilationProvider.Combine(classDeclarations.Collect());
//
//       // 3. Register the source output
//       context.RegisterSourceOutput(compilationAndClasses,
//                                    static (spc, source) => Execute(source.Item1, source.Item2, spc));
//    }
//
//    private static void Execute(Compilation compilation,
//                                ImmutableArray<ClassDeclarationSyntax> classes,
//                                SourceProductionContext context)
//    {
//       if (classes.IsDefaultOrEmpty)
//          return;
//
//       // Get the symbol for the INUI interface
//       var inuiInterfaceSymbol = compilation.GetTypeByMetadataName(INUI_TYPE_NAME);
//       if (inuiInterfaceSymbol == null)
//          // If INUI is not defined, we can't do anything.
//          return;
//
//       var inuiImplementerTypeNames = new List<string>();
//
//       // 4. Filter the classes to find the ones that implement INUI
//       foreach (var classSyntax in classes)
//       {
//          var semanticModel = compilation.GetSemanticModel(classSyntax.SyntaxTree);
//          if (semanticModel.GetDeclaredSymbol(classSyntax) is INamedTypeSymbol classSymbol)
//             if (classSymbol.AllInterfaces.Contains(inuiInterfaceSymbol, SymbolEqualityComparer.Default))
//                // We found a concrete class that implements INUI. Store its full name.
//                inuiImplementerTypeNames.Add(classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
//       }
//
//       if (!inuiImplementerTypeNames.Any())
//          return;
//
//       // 5. Generate the source code
//       var sourceCode = GenerateRegistryClass(inuiImplementerTypeNames);
//       context.AddSource("Debug.NUITypeRegistry.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
//    }
//
//    private static string GenerateRegistryClass(List<string> typeNames)
//    {
//       var builder = new StringBuilder();
//       builder.AppendLine("// <auto-generated/>");
//       builder.AppendLine("#nullable enable");
//       builder.AppendLine();
//       builder.AppendLine("#if DEBUG"); // This is the crucial part!
//       builder.AppendLine();
//       builder.AppendLine("using System;");
//       builder.AppendLine("using System.Collections.Generic;");
//       builder.AppendLine();
//       builder.AppendLine("namespace Arcanum.Core.DebugTools"); // Your desired namespace for the helper
//       builder.AppendLine("{");
//       builder.AppendLine("    /// <summary>");
//       builder.AppendLine("    /// A debug-only helper class, automatically generated to list all concrete types that implement INUI.");
//       builder.AppendLine("    /// </summary>");
//       builder.AppendLine("    public static class NUITypeRegistry");
//       builder.AppendLine("    {");
//       builder.AppendLine("        /// <summary>");
//       builder.AppendLine("        /// Gets a list of all concrete types that implement the INUI interface.");
//       builder.AppendLine("        /// </summary>");
//       builder.AppendLine("        public static IEnumerable<Type> GetAllNUITypes()");
//       builder.AppendLine("        {");
//
//       foreach (var typeName in typeNames.OrderBy(n => n))
//          builder.AppendLine($"            yield return typeof({typeName});");
//
//       builder.AppendLine("        }");
//       builder.AppendLine("    }");
//       builder.AppendLine("}");
//       builder.AppendLine();
//       builder.AppendLine("#endif");
//
//       return builder.ToString();
//    }
// }